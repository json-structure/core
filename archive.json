{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-03T00:45:15.036557+00:00",
  "repo": "json-structure/core",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "companion spec",
      "description": "candidate topic for a companion spec",
      "color": "a30bb9"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOONqYn86ztw5t",
      "title": "\"tuple\" type declaration of \"properties\" is problematic",
      "url": "https://github.com/json-structure/core/issues/2",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `properties` declaration is reused for the `tuple` type. That's an issue because the tuple is ordered and the `properties` declaration is an object where keys are unordered. \n\nI do like preserving the same declaration style as for `object` combined with the terseness of the encoding in an array.  \n\nNoting this as an issue while pondering the options.",
      "createdAt": "2025-04-23T19:55:26Z",
      "updatedAt": "2025-04-24T07:05:57Z",
      "closedAt": "2025-04-24T07:05:57Z",
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fix will be an ordering array that references the properties. The tuple still defines a data structure with property names such that it can be easily mapped to an object in a programming language or database.\n\n```\n{\n  \"type\": \"tuple\",\n  \"name\": \"Person\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"int32\" }\n  },\n  \"tuple\": [\"name\", \"age\"]\n}\n```",
          "createdAt": "2025-04-24T05:48:55Z",
          "updatedAt": "2025-04-24T05:48:55Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOONqYn86z9ZkN",
      "title": "Idea: Consider relaxing dict key charset restriction, rely on \"name\" instead of \"altnames.json\"",
      "url": "https://github.com/json-structure/core/issues/3",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just a suggestion / feedback on something that could be done *differently*, but the current proposal also works.\n\nInstead of applying the restricted charset ([Identifier Rules](https://json-structure.github.io/core/draft-vasters-json-structure-core.html#section-3.6)) to the dictionary keys AND to the `name`, we could make it more similar to how JSON Schema works today:\n\n- There are no limitation on dictionary key charset and it represents the JSON encoding name (`altnames.json`). If this contains restricted chars, it's mandatory to add `name` for codegen / tools.\n- The `altnames.json` can be removed, and it's not necessary to use a spec extension just to describe existing JSON / JS structures as they are.\n- Tools / codegens will always use `name` and fall back to the dictionary key.\n\nAdvantages from my view:\n- Closer to how JSON Schema works today\n- One less concept and one less spec extension to understand \n- I think that modeling existing JSON structures is very common, the new identifier name restrictions may only work consistently for greenfield / new models that are created in JSON Structure from start.\n\nDisadvantages:\n- Validation of correct JSON Structure document is more complicated, because the regexp validation on dictionary keys is conditional (only has to match regex if no `name` is provided).",
      "createdAt": "2025-04-25T07:21:44Z",
      "updatedAt": "2025-04-25T14:29:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The restriction of the character set of names is very intentional. I want to make sure that all names and namespaces can be cleanly mapped into databases and most common programming languages. Being able to define everyone's weird JSON document shapes is not a goal I am pursuing. altnames/json is a way to hack around that restriction and the pain of doing that is also intentional. \n\nthere are a few cases where \"name\" doesn't have a map above it and therefore this proposal would not work for those cases. ",
          "createdAt": "2025-04-25T11:18:15Z",
          "updatedAt": "2025-04-25T11:18:15Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "@clemensv - yes, I understood that and fully agree that this is useful. The charset restriction of `name` would stay exactly like it is. \n\nBut if `name` can't be put in every place where it's needed, this approach would cause issues. Where would this be? ",
          "createdAt": "2025-04-25T14:29:14Z",
          "updatedAt": "2025-04-25T14:29:20Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOONqYn86z9g6z",
      "title": "Feature: Support Associations",
      "url": "https://github.com/json-structure/core/issues/4",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In my experience, one of the biggest gaps of JSON Schema is that it's not possible to describe associations. Both IDs and associations are just \"string\" or maybe \"UUID\" format if you're lucky. This is probably due to JSON Schema only focusing on validation, not on describing models. \n\nJSON Structure is already much better suited to describe models, but it would be important to also explicitly model the associations, e.g. to express FK relationships in database schemas or references / associations in API models. \n\nThere are many ways to go about it, we could collect them here. \n\n### PRs\n\n- https://github.com/json-structure/core/pull/7\n- https://github.com/json-structure/core/pull/8\n\n### Initial Proposal\n\nA first initial, simpler proposal (partially discussed with Clemens) could look like this. \n\n- Add new structural keyword `id` to object and , which is an array of property names that are the \"primary ID\" that are used to reference to it. This is usually one value, but if its multiple, we have a \"composite ID\". \n- Add a new structural keyword `targettype` to properties, the value is a JSON Pointer to the association target object. The target MSUT be an object and MUST have use the `id` keyword.\n- Cardinality is known through `required` and whether the association is within an `array` or not.\n- We do not need a dedicated `association` type, because it's useful to know the type of the ID itself (could be string, UUID, number, ...). We know something is an ID, because we marked it with `id` and we know something is an association by having the `targettype` keyword in it.\n- Polymorphic associations could probably be covered by wrapping this into a `choice`. (@clemensv ?)\n\n### Gaps / Open Questions \n- For composite IDs and References, we still don't know which source object property maps to which target object property. If this is needed to understand (e.g. to automatically construct query join conditions or code that joins the associations), we need to define this mapping.\n  - Maybe we could add a `targetproperty` in this case, where the property name for the corresponding ID is stated. EDIT: This alone is not sufficient if one object has more than one association to the same target. In this case, it's necessary to know which properties on the source object together form one composite association to the target objects composite ID (and how the properties each map). \n- Not sure if we could also use `abstract` objects for polymorphic associations. In this case, you could point to the abstract object, it defines the shared `id`. All concrete implementations of the abstract object are then valid association targets. ",
      "createdAt": "2025-04-25T07:35:56Z",
      "updatedAt": "2025-04-29T13:57:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think of your proposal as three (!) features that compose:\n\n1) The `targettype` annotation for `jsonpointer` typed schemas simply creates a constraint for what JSON node the JSON Pointer may point at, nothing more. \n\n2) The optional, array-of-string valued `id` annotation for `object` (and `tuple`) establishes a set of identifiers that MUST, in combination, be unique for each instance. That is also a feature that puts a constraint on instances (the check will have to span instances of all usages of the type independent of where they appear in a document). \n\n3) If a `jsonpointer` points from some type property to another `targettype`, and that `targettype` has a declared `id`, a mapping into a database can use that information to construct a foreign key relationship. If there are mutual relationships, of that sort, that may cause an extra table to be created. That's basically a side-product of 1) and 2). \n\nPolymorphic associations would point to a `choice`, yes. For an inline discriminator `choice`, the base class would have to define the `id` already.",
          "createdAt": "2025-04-25T09:25:48Z",
          "updatedAt": "2025-04-25T09:25:48Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "Yes, it makes sense to compose it to separate feature requests / PRs. Maybe an additional one to support composite IDs via `targetproperty` (or something else) - but that is not needed for a first iteration.\n\nThose 2 first features could be separate PRs (should I create them?) and work together to get the associations as a feature into JSON Structure.\n\nFeature 3 is then more of a implication?",
          "createdAt": "2025-04-25T09:28:37Z",
          "updatedAt": "2025-04-25T09:45:33Z"
        },
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, 3 is a result of 1 and 2. If you want to create PRs, go right ahead!",
          "createdAt": "2025-04-25T21:00:24Z",
          "updatedAt": "2025-04-25T21:00:24Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOONqYn860GhWp",
      "title": "Section 3.8 - Prohibit type annotations with type unions",
      "url": "https://github.com/json-structure/core/issues/5",
      "state": "OPEN",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a clause that explicitly prohibits using type annotations in schemas where the type is a type-union.\n\nThis prevents ambiguous definitions where the type union includes a combination of types (e.g. [\"string\", \"decimal\"]) and the annotation would only apply to  one of the types.\n\nTo achieve a type union of further constrained types, one must define them as reusable types and type-union those.\n\nThe prohibition will also extend to and be repeated in the validation spec.",
      "createdAt": "2025-04-26T08:04:18Z",
      "updatedAt": "2025-04-26T08:04:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOONqYn860exCx",
      "title": "Clarify encoding of `$ref`",
      "url": "https://github.com/json-structure/core/issues/6",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "The JSON Pointer for `$ref` is encoded with a leading '#' and thus leans on RFC6901 Section 6 to ease composition for deep-links; that's not noted in the draft at the moment and should be. ",
      "createdAt": "2025-04-29T11:25:17Z",
      "updatedAt": "2025-07-02T12:36:00Z",
      "closedAt": "2025-07-02T12:36:00Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOONqYn867lmws",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/issues/9",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "`map` keys are currently restricted to the identifier character set. Since `map` keys are unlikely to be mapped to column names or variable names while projecting a JSON Structure onto a database or programming language, we can lift the restriction.",
      "createdAt": "2025-06-15T07:15:36Z",
      "updatedAt": "2025-06-15T07:32:13Z",
      "closedAt": "2025-06-15T07:32:12Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOONqYn86SnC9e",
      "title": "Introducing choice type",
      "url": "https://github.com/json-structure/core/pull/1",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This edit introduces the choice type for discriminated unions.",
      "createdAt": "2025-04-15T06:40:40Z",
      "updatedAt": "2025-04-22T11:20:16Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "b0c1472fb4714d8805af0f92659f2538d9e5ee03",
      "headRepository": "json-structure/core",
      "headRefName": "add-choice",
      "headRefOid": "ebea75e6290da25d1e91f5fdd22e76516564a858",
      "closedAt": "2025-04-22T11:20:12Z",
      "mergedAt": "2025-04-22T11:20:11Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "8f83b3da08ff5e86d8fe3566ed501f34ba58fcd6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOONqYn86UWdJa",
      "title": "Add id keyword to objects to state primary IDs",
      "url": "https://github.com/json-structure/core/pull/7",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nThis adds just the `id` keyword. \r\n\r\nThere will be another PR to also add the `targettype` keyword on property level. ",
      "createdAt": "2025-04-29T13:35:39Z",
      "updatedAt": "2025-07-02T13:01:32Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-id-keyword",
      "headRefOid": "240f7c05cbb9a898b10161c838bff9276682ed81",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nG6d2",
          "commit": {
            "abbreviatedOid": "0bff4c8"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:42:26Z",
          "updatedAt": "2025-04-29T13:42:27Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe `id` MUST only be used on objects.\r\nThe value MUST be an array of property names of the current object.\r\n```",
              "createdAt": "2025-04-29T13:42:26Z",
              "updatedAt": "2025-04-29T13:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHVol",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:59:11Z",
          "updatedAt": "2025-04-29T13:59:11Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Maybe more explicit:\r\n\r\n```suggestion\r\n              \"primaryid\": [\"ID\"],\r\n```",
              "createdAt": "2025-04-29T13:59:11Z",
              "updatedAt": "2025-04-29T13:59:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xiFYO",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@Fannon Let me know whether you can still adapt this; otherwise I can take this one over.",
          "createdAt": "2025-07-02T09:49:30Z",
          "updatedAt": "2025-07-02T09:57:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "\"identity\" will be clearer",
              "createdAt": "2025-07-02T09:49:30Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 6,
              "body": "objects and tuples.",
              "createdAt": "2025-07-02T09:49:46Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 7,
              "body": "lists the properties, in the role of identifiers,  that establish an unambiguous identity of an instance. Providing more than one property reference indicates a composite identity, not a list of alternate identifiers.",
              "createdAt": "2025-07-02T09:53:21Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 21,
              "body": "\"identity \" should be clear.",
              "createdAt": "2025-07-02T09:53:53Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 31,
              "body": "Identity SHOULD be used on object and tuple declarations. I assume the reason why you want to make it mandatory is the association feature, but I think that will just not work when there is no identity and that might be okay. ",
              "createdAt": "2025-07-02T09:56:18Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjJcz",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:27:58Z",
          "updatedAt": "2025-07-02T11:27:58Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Ah, I only wanted to make the statement that they must only be used on objects, but there they would be optional. \r\n\r\nI agree, they should be optional. Not every object may need an identity, e.g. value objects.",
              "createdAt": "2025-07-02T11:27:58Z",
              "updatedAt": "2025-07-02T11:27:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOONqYn86UWuQU",
      "title": "Propose targettype keyword for associations",
      "url": "https://github.com/json-structure/core/pull/8",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nBuilds upon #7 \r\n\r\nAdds the `targettype` keyword to indicate associations / references / pointers within the model.",
      "createdAt": "2025-04-29T13:56:45Z",
      "updatedAt": "2025-07-02T13:00:35Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-targettype-keyword",
      "headRefOid": "8cbb31c63f96cd2934dec798d268dca2330067f9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think identities and relations would be a good companion spec. ",
          "createdAt": "2025-07-02T11:16:38Z",
          "updatedAt": "2025-07-02T11:16:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nHUsa",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:58:36Z",
          "updatedAt": "2025-04-29T13:58:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Other possible keyword names:\r\n\r\n```suggestion\r\n### `target` Keyword {#targettype-keyword}\r\n```\r\n\r\n```suggestion\r\n### `targetobject` Keyword {#targettype-keyword}\r\n```",
              "createdAt": "2025-04-29T13:58:37Z",
              "updatedAt": "2025-04-29T13:58:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHYCi",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T14:00:44Z",
          "updatedAt": "2025-04-29T14:00:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "@clemensv : Could it also appear in set and tuple?",
              "createdAt": "2025-04-29T14:00:44Z",
              "updatedAt": "2025-04-29T14:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjAp7",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:15:16Z",
          "updatedAt": "2025-07-02T11:15:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree with the direction of this, but I would make this broader:\r\n\r\nFor objects and tuples, I would add a new keyword \"relations\" that is similar to \"properties\" but specifically defines relationship properties. \"relations\" and \"properties\" share a namespace, so they can't define conflicting names.\r\n\r\nThe \"relations\" declarations are not modeled as types, because they must be able to cross-reference properties within the same tuple/object. They are similar to properties in that they are represented just like properties in the instances.\r\n\r\nA `relation` is a named object (via the `relations` map) that has two properties:\r\n\r\n- the `targettype` declares the target type that the relation refers to\r\n- the `cardinality` declares whether the relationship point to one or more targets\r\n\r\nthe targettype's `identity` declaration functions like the `tuple` keyword for establishing the type of references, meaning that if the target's `identity` clause references two properties, the reference value in the relation source is a tuple-encoded list of values matching that identity.\r\n\r\nAn instance of a single relation is an object with the following properties:\r\n\r\n\"ref\" : a JSON pointer to the target object\r\n\"identity\": a tuple that reflects the target object identity values\r\n\r\nA relationship MAY be established either through a direct link (ref) or through an `identity` match against all known instances of the target type. If both properties are defined, the `identity` match is performed against all instances of the target type that exists within the scope of the `ref` json pointer, i.e. are children of the identified node.\r\n\r\nthe value of relations with `multiple` cardinality is an array of such objects. the value of relations with `single` cardinality is a single such object.\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://json-structure.org/meta/core/v0/#\",\r\n  \"$id\":     \"https://example.com/library.schema\",\r\n  \"$root\":   \"#/definitions/Library/Document\",\r\n\r\n  \"definitions\": {\r\n    \"Library\": {\r\n\r\n      /* 1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  AUTHOR  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Author\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Author\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  PUBLISHER  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Publisher\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Publisher\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" },\r\n          \"city\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  BOOK  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Book\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Book\",\r\n\r\n        /* intrinsic fields only \u2014 reference\r\n           properties are implicit via `relations` */\r\n        \"properties\": {\r\n          \"isbn\":  { \"type\": \"string\" },\r\n          \"title\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"isbn\", \"title\"],\r\n        \"identity\": [\"isbn\"],\r\n\r\n        \"relations\": {\r\n          /* many Authors per Book  */\r\n          \"authors\": {\r\n            \"cardinality\": \"multiple\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n          /* exactly one Publisher per Book */\r\n          \"publisher\": {\r\n            \"cardinality\": \"single\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          }\r\n        }\r\n      },\r\n\r\n      /* 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  DOCUMENT ROOT  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Document\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"LibraryDocument\",\r\n        \"properties\": {\r\n          /* list of all authors present in this file */\r\n          \"authors\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n\r\n          /* list of all publishers */\r\n          \"publishers\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          },\r\n\r\n          /* list of all books */\r\n          \"books\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Book\" }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nInstance:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n  \"authors\": [\r\n    {\r\n      \"id\":   \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\",\r\n      \"name\": \"Brian W. Kernighan\"\r\n    },\r\n    {\r\n      \"id\":   \"b3e0fac1-603f-4960-8646-90b053b6af19\",\r\n      \"name\": \"Dennis M. Ritchie\"\r\n    }\r\n  ],\r\n  \"publishers\": [\r\n    {\r\n      \"id\":   \"9609d302-62fb-4d0a-9e71-86f744e3022c\",\r\n      \"name\": \"Prentice Hall\"\r\n    }\r\n  ],\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n      \"authors\": [\r\n        {\r\n          \"ref\":      \"#/authors/0\",\r\n          \"identity\": [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"]\r\n        },\r\n        {\r\n          \"ref\":      \"#/authors/1\",\r\n          \"identity\": [\"b3e0fac1-603f-4960-8646-90b053b6af19\"]\r\n        }\r\n      ],\r\n      \"publisher\": {\r\n        \"ref\":      \"#/publishers/0\",\r\n        \"identity\": [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nI explicitly made the `relation` instance an object, because that gives us the opportunity to declare a `qualifier` type in the `relation` which defines/references a type to qualify the relationship further, equivalent to link properties in a graph.\r\n\r\nExample:\r\n\r\nqualifier type:\r\n\r\n```\r\n\"AuthorRole\": {\r\n  \"type\": \"string\",\r\n  \"enum\": [\"Author\", \"Editor\", \"Illustrator\", \"Translator\"]\r\n}\r\n```\r\n\r\nextend the relation:\r\n\r\n```\r\n\"authors\": {\r\n  \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" },\r\n  \"cardinality\": \"multiple\",\r\n\r\n  /* NEW \u2013 the schema that qualifies the link                *\r\n   * Every relation-instance object MUST carry a `qualifier`  *\r\n   * that validates against this type.                       */\r\n  \"qualifiertype\": { \"$ref\": \"#/definitions/Library/AuthorRole\" }\r\n}\r\n```\r\n\r\nInstance with qualifiers:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n\r\n  \"authors\": [\r\n    { \"id\": \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\", \"name\": \"Brian W. Kernighan\" },\r\n    { \"id\": \"b3e0fac1-603f-4960-8646-90b053b6af19\", \"name\": \"Dennis M. Ritchie\" }\r\n  ],\r\n\r\n  \"publishers\": [\r\n    { \"id\": \"9609d302-62fb-4d0a-9e71-86f744e3022c\", \"name\": \"Prentice Hall\" }\r\n  ],\r\n\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n\r\n      \"authors\": [\r\n        {\r\n          \"ref\":       \"#/authors/0\",\r\n          \"identity\":  [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"],\r\n          \"qualifier\": \"Author\"          // \u2190 validated by AuthorRole enum\r\n        },\r\n        {\r\n          \"ref\":       \"#/authors/1\",\r\n          \"identity\":  [\"b3e0fac1-603f-4960-8646-90b053b6af19\"],\r\n          \"qualifier\": \"Author\"\r\n        }\r\n      ],\r\n\r\n      \"publisher\": {\r\n        \"ref\":       \"#/publishers/0\",\r\n        \"identity\":  [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n        /* no qualifier here because the relation         *\r\n         * lacks a `qualifiertype` in the declaration.    */\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n    ",
              "createdAt": "2025-07-02T11:15:16Z",
              "updatedAt": "2025-07-02T11:15:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOONqYn86aktrc",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/pull/10",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #9\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-06-15T07:30:48Z",
      "updatedAt": "2025-06-15T07:32:21Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue9",
      "headRefOid": "bf4e6e8d219a8d636cbccaacee32e25df2a25fb1",
      "closedAt": "2025-06-15T07:32:12Z",
      "mergedAt": "2025-06-15T07:32:12Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOONqYn86dE9Wn",
      "title": "Clemensv/issue6",
      "url": "https://github.com/json-structure/core/pull/11",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #6\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-07-02T12:35:50Z",
      "updatedAt": "2025-07-02T12:36:11Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue6",
      "headRefOid": "cce9997c2154723262149595d31ab1ce561ae6cf",
      "closedAt": "2025-07-02T12:35:58Z",
      "mergedAt": "2025-07-02T12:35:58Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "4aeb7e24ee63935d52e768631e4f6c892851c19f"
      },
      "comments": [],
      "reviews": []
    }
  ]
}