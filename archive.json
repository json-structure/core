{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-12-02T00:45:45.254980+00:00",
  "repo": "json-structure/core",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "companion spec",
      "description": "candidate topic for a companion spec",
      "color": "a30bb9"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOONqYn86ztw5t",
      "title": "\"tuple\" type declaration of \"properties\" is problematic",
      "url": "https://github.com/json-structure/core/issues/2",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `properties` declaration is reused for the `tuple` type. That's an issue because the tuple is ordered and the `properties` declaration is an object where keys are unordered. \n\nI do like preserving the same declaration style as for `object` combined with the terseness of the encoding in an array.  \n\nNoting this as an issue while pondering the options.",
      "createdAt": "2025-04-23T19:55:26Z",
      "updatedAt": "2025-04-24T07:05:57Z",
      "closedAt": "2025-04-24T07:05:57Z",
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fix will be an ordering array that references the properties. The tuple still defines a data structure with property names such that it can be easily mapped to an object in a programming language or database.\n\n```\n{\n  \"type\": \"tuple\",\n  \"name\": \"Person\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"int32\" }\n  },\n  \"tuple\": [\"name\", \"age\"]\n}\n```",
          "createdAt": "2025-04-24T05:48:55Z",
          "updatedAt": "2025-04-24T05:48:55Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOONqYn86z9ZkN",
      "title": "Idea: Consider relaxing dict key charset restriction, rely on \"name\" instead of \"altnames.json\"",
      "url": "https://github.com/json-structure/core/issues/3",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just a suggestion / feedback on something that could be done *differently*, but the current proposal also works.\n\nInstead of applying the restricted charset ([Identifier Rules](https://json-structure.github.io/core/draft-vasters-json-structure-core.html#section-3.6)) to the dictionary keys AND to the `name`, we could make it more similar to how JSON Schema works today:\n\n- There are no limitation on dictionary key charset and it represents the JSON encoding name (`altnames.json`). If this contains restricted chars, it's mandatory to add `name` for codegen / tools.\n- The `altnames.json` can be removed, and it's not necessary to use a spec extension just to describe existing JSON / JS structures as they are.\n- Tools / codegens will always use `name` and fall back to the dictionary key.\n\nAdvantages from my view:\n- Closer to how JSON Schema works today\n- One less concept and one less spec extension to understand \n- I think that modeling existing JSON structures is very common, the new identifier name restrictions may only work consistently for greenfield / new models that are created in JSON Structure from start.\n\nDisadvantages:\n- Validation of correct JSON Structure document is more complicated, because the regexp validation on dictionary keys is conditional (only has to match regex if no `name` is provided).",
      "createdAt": "2025-04-25T07:21:44Z",
      "updatedAt": "2025-04-25T14:29:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The restriction of the character set of names is very intentional. I want to make sure that all names and namespaces can be cleanly mapped into databases and most common programming languages. Being able to define everyone's weird JSON document shapes is not a goal I am pursuing. altnames/json is a way to hack around that restriction and the pain of doing that is also intentional. \n\nthere are a few cases where \"name\" doesn't have a map above it and therefore this proposal would not work for those cases. ",
          "createdAt": "2025-04-25T11:18:15Z",
          "updatedAt": "2025-04-25T11:18:15Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "@clemensv - yes, I understood that and fully agree that this is useful. The charset restriction of `name` would stay exactly like it is. \n\nBut if `name` can't be put in every place where it's needed, this approach would cause issues. Where would this be? ",
          "createdAt": "2025-04-25T14:29:14Z",
          "updatedAt": "2025-04-25T14:29:20Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOONqYn86z9g6z",
      "title": "Feature: Support Associations",
      "url": "https://github.com/json-structure/core/issues/4",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In my experience, one of the biggest gaps of JSON Schema is that it's not possible to describe associations. Both IDs and associations are just \"string\" or maybe \"UUID\" format if you're lucky. This is probably due to JSON Schema only focusing on validation, not on describing models. \n\nJSON Structure is already much better suited to describe models, but it would be important to also explicitly model the associations, e.g. to express FK relationships in database schemas or references / associations in API models. \n\nThere are many ways to go about it, we could collect them here. \n\n### PRs\n\n- https://github.com/json-structure/core/pull/7\n- https://github.com/json-structure/core/pull/8\n\n### Initial Proposal\n\nA first initial, simpler proposal (partially discussed with Clemens) could look like this. \n\n- Add new structural keyword `id` to object and , which is an array of property names that are the \"primary ID\" that are used to reference to it. This is usually one value, but if its multiple, we have a \"composite ID\". \n- Add a new structural keyword `targettype` to properties, the value is a JSON Pointer to the association target object. The target MSUT be an object and MUST have use the `id` keyword.\n- Cardinality is known through `required` and whether the association is within an `array` or not.\n- We do not need a dedicated `association` type, because it's useful to know the type of the ID itself (could be string, UUID, number, ...). We know something is an ID, because we marked it with `id` and we know something is an association by having the `targettype` keyword in it.\n- Polymorphic associations could probably be covered by wrapping this into a `choice`. (@clemensv ?)\n\n### Gaps / Open Questions \n- For composite IDs and References, we still don't know which source object property maps to which target object property. If this is needed to understand (e.g. to automatically construct query join conditions or code that joins the associations), we need to define this mapping.\n  - Maybe we could add a `targetproperty` in this case, where the property name for the corresponding ID is stated. EDIT: This alone is not sufficient if one object has more than one association to the same target. In this case, it's necessary to know which properties on the source object together form one composite association to the target objects composite ID (and how the properties each map). \n- Not sure if we could also use `abstract` objects for polymorphic associations. In this case, you could point to the abstract object, it defines the shared `id`. All concrete implementations of the abstract object are then valid association targets. ",
      "createdAt": "2025-04-25T07:35:56Z",
      "updatedAt": "2025-04-29T13:57:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think of your proposal as three (!) features that compose:\n\n1) The `targettype` annotation for `jsonpointer` typed schemas simply creates a constraint for what JSON node the JSON Pointer may point at, nothing more. \n\n2) The optional, array-of-string valued `id` annotation for `object` (and `tuple`) establishes a set of identifiers that MUST, in combination, be unique for each instance. That is also a feature that puts a constraint on instances (the check will have to span instances of all usages of the type independent of where they appear in a document). \n\n3) If a `jsonpointer` points from some type property to another `targettype`, and that `targettype` has a declared `id`, a mapping into a database can use that information to construct a foreign key relationship. If there are mutual relationships, of that sort, that may cause an extra table to be created. That's basically a side-product of 1) and 2). \n\nPolymorphic associations would point to a `choice`, yes. For an inline discriminator `choice`, the base class would have to define the `id` already.",
          "createdAt": "2025-04-25T09:25:48Z",
          "updatedAt": "2025-04-25T09:25:48Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "Yes, it makes sense to compose it to separate feature requests / PRs. Maybe an additional one to support composite IDs via `targetproperty` (or something else) - but that is not needed for a first iteration.\n\nThose 2 first features could be separate PRs (should I create them?) and work together to get the associations as a feature into JSON Structure.\n\nFeature 3 is then more of a implication?",
          "createdAt": "2025-04-25T09:28:37Z",
          "updatedAt": "2025-04-25T09:45:33Z"
        },
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, 3 is a result of 1 and 2. If you want to create PRs, go right ahead!",
          "createdAt": "2025-04-25T21:00:24Z",
          "updatedAt": "2025-04-25T21:00:24Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOONqYn860GhWp",
      "title": "Section 3.8 - Prohibit type annotations with type unions",
      "url": "https://github.com/json-structure/core/issues/5",
      "state": "OPEN",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a clause that explicitly prohibits using type annotations in schemas where the type is a type-union.\n\nThis prevents ambiguous definitions where the type union includes a combination of types (e.g. [\"string\", \"decimal\"]) and the annotation would only apply to  one of the types.\n\nTo achieve a type union of further constrained types, one must define them as reusable types and type-union those.\n\nThe prohibition will also extend to and be repeated in the validation spec.",
      "createdAt": "2025-04-26T08:04:18Z",
      "updatedAt": "2025-04-26T08:04:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOONqYn860exCx",
      "title": "Clarify encoding of `$ref`",
      "url": "https://github.com/json-structure/core/issues/6",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "The JSON Pointer for `$ref` is encoded with a leading '#' and thus leans on RFC6901 Section 6 to ease composition for deep-links; that's not noted in the draft at the moment and should be. ",
      "createdAt": "2025-04-29T11:25:17Z",
      "updatedAt": "2025-07-02T12:36:00Z",
      "closedAt": "2025-07-02T12:36:00Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOONqYn867lmws",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/issues/9",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "`map` keys are currently restricted to the identifier character set. Since `map` keys are unlikely to be mapped to column names or variable names while projecting a JSON Structure onto a database or programming language, we can lift the restriction.",
      "createdAt": "2025-06-15T07:15:36Z",
      "updatedAt": "2025-06-15T07:32:13Z",
      "closedAt": "2025-06-15T07:32:12Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOONqYn87Cgvd-",
      "title": "Compare to JSON-Schema.org",
      "url": "https://github.com/json-structure/core/issues/12",
      "state": "OPEN",
      "author": "aurium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Don't get me wrong. I thought this was great!\nWhoever, I think you could put it clearly somewhere:\n\n  * Why JSON Structure when you have other mature alternatives?\n  * Where JSON Structure differs to JSON Schema?\n  * In what cases is this superior to JSON Schema?\n",
      "createdAt": "2025-07-25T14:10:16Z",
      "updatedAt": "2025-08-13T14:46:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The primer aims to provide that: https://github.com/json-structure/primer-and-samples/blob/main/json-structure-primer.md",
          "createdAt": "2025-08-13T14:46:41Z",
          "updatedAt": "2025-08-13T14:46:41Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOONqYn87HE52k",
      "title": "Relationship to RFC 8927 (JSON Type Definition)?",
      "url": "https://github.com/json-structure/core/issues/13",
      "state": "OPEN",
      "author": "gsnedders",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [primer](https://github.com/json-structure/primer-and-samples/blob/main/json-structure-primer.md) says:\n\n> There are rapidly growing needs for a standardized (IETF RFC) schema language that can describe data types and structures and whose definitions map cleanly to programming language types and database constructs as well as into the popular JSON data encoding.\n\nIt goes on to talk about JSON Schema.\n\nHowever, it doesn't mention RFC 8927 (JSON Type Definition) whatsoever, which is already a published RFC.",
      "createdAt": "2025-08-21T01:22:20Z",
      "updatedAt": "2025-11-27T22:44:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gsnedders Thank you for the note. The experimental RFC 8927 hasn't shown up for me in any real customer scenario while JSON Schema does all the time. JSON Schema is incredibly popular in spite of all of its faults and my sense is that part of the attraction is that the simple scenarios like declaring a simple object type are straightforward. ",
          "createdAt": "2025-11-27T22:44:16Z",
          "updatedAt": "2025-11-27T22:44:16Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOONqYn87RN51y",
      "title": "New base32hex 26-character unpadded format for UUID",
      "url": "https://github.com/json-structure/core/issues/14",
      "state": "OPEN",
      "author": "sergeyprokhorenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It is necessary to expand the wording:\n\n3.2.2.20. uuid\nA universally unique identifier.\u00b6\n* Base type: string\u00b6\n* Constraints:\u00b6\n    * The string value MUST conform to the [RFC9562] UUID format **or [RFC4648] base32hex 26-character unpadded format.\u00b6**\n\nSee https://github.com/x4m/postgres_g/commit/aa902bbc5dfc47d4b35f05016304a1e671abb505",
      "createdAt": "2025-10-13T13:29:11Z",
      "updatedAt": "2025-11-28T08:02:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sergeyprokhorenko I will review",
          "createdAt": "2025-11-27T22:39:03Z",
          "updatedAt": "2025-11-27T22:39:03Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@clemensv\n\nThe authors of RFC 9562 are currently considering including one of the UUID encodings, Base64Sort or Base52Sort, in the standard. A decision has not yet been made. Base32hex is unlikely to be included in the standard, as it is less compact.\n\n",
          "createdAt": "2025-11-28T07:29:46Z",
          "updatedAt": "2025-11-28T07:29:46Z"
        },
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sergeyprokhorenko should we add a type qualifier that selects the encoding?",
          "createdAt": "2025-11-28T07:33:21Z",
          "updatedAt": "2025-11-28T07:33:21Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@clemensv\n\n> should we add a type qualifier that selects the encoding?\n\nYes, this is a good solution",
          "createdAt": "2025-11-28T08:02:56Z",
          "updatedAt": "2025-11-28T08:02:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOONqYn87W4iAS",
      "title": "Proposal for flexible numeric types inspired by the ADA type system",
      "url": "https://github.com/json-structure/core/issues/15",
      "state": "OPEN",
      "author": "ThyMYthOS",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "### Proposal for a More Flexible Numeric Type System\n\nFirst, thank you for the work on this draft. The clear and strict type system is a great foundation.\n\nThis proposal suggests enhancing the numeric type system to be more flexible and descriptive, allowing for the precise definition of numeric types with arbitrary precision, particularly for scientific, financial, and hardware-interfacing applications.\n\n### Current State\n\nThe current specification defines a useful set of fixed-size numeric types (`int8`...`int128`, `float`, `double`) and a `decimal` type for high precision. It also lists `precision` and `scale` as annotation keywords (3.8.2, 3.8.3).\n\nHowever, this system could be made more expressive. For example, it's not explicitly clear how to define:\n\n- A floating-point number with a minimum required decimal precision (not just float or double).\n- A binary fixed-point number with a specific delta (absolute error).\n- A decimal fixed-point number (which decimal + precision + scale may cover, but could be more explicit).\n- A modular (wrap-around) integer type, common in many systems.\n\n### Inspiration: The ADA Type System\n\nThe ADA language provides an excellent model for defining numeric types based on their requirements rather than their implementation. This makes schemas more portable and semantically rich.\n\nWe could adopt a similar model by clarifying and extending the use of the precision and scale keywords, and perhaps introducing a new keyword like model to define the numeric representation.\n\nThis proposal suggests an approach that:\n * Uses the standard type property (\"number\" or \"string\") to define the storage representation of the value in the JSON document.\n * Adds new \"qualifier\" properties (e.g., `representation`, `radix`) at the same level as type to specify the exact semantics.\nThe type is set to `\"number\"` if the value can be losslessly represented by a standard JSON number (IEEE 754 double). Otherwise, type is set to `\"string\"` to hold the high-precision value.\n\n**Proposed Properties**\n * `type`: `\"number\"` | `\"string\"` _(Required)_\n * `representation`: `\"integer\"` | `\"floating\"` | `\"fixed\"` | `\"rational\"` | `\"modular\"` _(Required for this proposal)_\n * `radix`: `\"binary\"` | `\"decimal\"` _(Required for integer, fixed, and floating)_\n * `precision`: `integer` _(Optional. The number of significant bits/digits)_\n   * For integer and fixed: The total number of bits (if radix: \"binary\") or digits (if radix: \"decimal\").\n   * For floating: The number of bits (if radix: \"binary\") or digits (if radix: \"decimal\") in the mantissa.\n * `scale`: `integer` _(Optional. Required for fixed representation. The number of fractional bits/digits)._\n * `modulus`: `string` | `number` _(Optional. Required for modular representation. Same type as indicated by `type`)._\n * `minimum`: `string` | `number` _(Optional. The inclusive minimum valid value, as a string for arbitrary precision)._\n * `maximum`: `string` | `number` _(Optional. The inclusive maximum valid value, as a string for arbitrary precision)._\n * `exclusiveMinimum`: `string` | `number` _(Optional. The exclusive minimum valid value, as a string for arbitrary precision)._\n * `exclusiveMaximum`: `string` | `number` _(Optional. The exclusive maximum valid value, as a string for arbitrary precision)._\n\n### Relationship to Current Definitions\nThis proposal can be seen as a superset of the numeric types currently defined in the JSON Structure Core draft (e.g., uint8, int32, float64).\nThose definitions can be expressed using this proposal:\n * uint8:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 8,\n  \"minimum\": \"0\",\n  \"exclusiveMaximum\": \"256\"\n```\n * int32:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 32,\n  \"minimum\": \"-2147483648\",\n  \"exclusiveMaximum\": \"2147483648\"\n```\n * float64 (IEEE 754 Double):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"floating\",\n  \"radix\": \"binary\",\n  \"precision\": 53,\n  \"minimum\": \"-1.7976931348623157e+308\",\n  \"maximum\": \"1.7976931348623157e+308\"\n```\n   _(Note: precision is 53 for the bits in the mantissa. Inclusive min/max is standard for float definitions)._\n\nThe key limitation of the current definitions is that they are restricted to power-of-two, binary types. This proposal extends support to:\n * Non-power-of-two binary types: e.g., a 10-bit integer from a sensor.\n * Decimal types: e.g., DECIMAL(19, 4) for finance, which cannot be losslessly represented by float64.\nThis proposal provides a single, unified system for defining all of them.\n\n### Examples\nHere is how this system would define various numeric types.\n1. Binary Integer\n * Concept: A base-2 integer.\n * Schema (for uint10 sensor reading):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 10,\n  \"minimum\": 0,\n  \"exclusiveMaximum\": 1024\n ```\n * Schema (for int128):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 128,\n  \"minimum\": \"-170141183460469231731687303715884105728\",\n  \"exclusiveMaximum\": \"170141183460469231731687303715884105728\"\n```\n2. Binary Floating Point\n * Concept: A base-2 floating-point number.\n * Schema (for binary64/double):\n   * (See \"Relationship to Current Definitions\" section)\n * Schema (for arbitrary 512-bit float):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"floating\",\n  \"radix\": \"binary\",\n  \"precision\": 450\n```\n3. Binary Fixed Point\n * Concept: A base-2 fixed-point number (e.g., Q notation).\n * Schema (for Q24.8, 32-bit total):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"fixed\",\n  \"radix\": \"binary\",\n  \"precision\": 32,\n  \"scale\": 8,\n  \"minimum\": -8388608,\n  \"exclusiveMaximum\": 8388608\n```\n4. Decimal Floating Point\n * Concept: A base-10 floating-point number.\n * Schema (for decimal128, 34-digit mantissa):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"floating\",\n  \"radix\": \"decimal\",\n  \"precision\": 34\n```\n5. Decimal Fixed Point\n * Concept: Standard for currency (DECIMAL(p, s)).\n * Schema (for DECIMAL(19, 4)):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"fixed\",\n  \"radix\": \"decimal\",\n  \"precision\": 19,\n  \"scale\": 4,\n  \"exclusiveMinimum\": \"-1000000000000000\",\n  \"exclusiveMaximum\": \"1000000000000000\"\n```\n * Schema (for DECIMAL(10, 2)):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"fixed\",\n  \"radix\": \"decimal\",\n  \"precision\": 10,\n  \"scale\": 2,\n  \"exclusiveMinimum\": -100000000,\n  \"exclusiveMaximum\": 100000000\n```\n6. Rational Numbers\n * Concept: A number as a ratio of two integers.\n * Schema:\n ```json\n  \"type\": \"string\",\n  \"representation\": \"rational\"\n```\n7. Modular Types\n * Concept: An integer that wraps around.\n * Schema (for mod 360), e.g. heading in degrees:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"modular\",\n  \"modulus\": \"360\"\n```\n * Schema (for mod 2**256):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"modular\",\n  \"modulus\": \"115792089237316195423570985008687907853269984665640564039457584007913129639936\",\n  \"minimum\": \"0\",\n  \"exclusiveMaximum\": \"115792089237316195423570985008687907853269984665640564039457584007913129639936\"\n```\n\n### Benefits of This Approach\n * Backwards-Compatible: Parsers that don't understand the new properties still see a valid JSON type (`\"number\"` or `\"string\"`).\n * Explicit Storage: Clearly separates the logical numeric type from its physical storage in the JSON document.\n * Unambiguous Deserialization: A consumer knows whether to parse a value from a string or use the native number, and knows what precise data type (e.g., `Decimal`, `BigInt`) to deserialize it into.\n * Extensible: Unifies all numeric types (current and future) under one flexible system.",
      "createdAt": "2025-11-09T15:55:22Z",
      "updatedAt": "2025-11-28T07:37:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ThyMYthOS thank you for the proposal. I agree this is more factored than the more fixed model that exists at present. To upside of the fixed model is that it's easier to implement and validate than the infinite combinations you can create with these composable settings. I'm not sure that a \"uint10\" sensor reading is a thing. Ultimately, the vast majority of stuff works on byte boundaries.\n\nIf we go so far that we create 10 bit integers, I wonder what happens to the other 6 bits in those two bytes?\n\nIt might be worth exploring a bitfield complex type that is similar to tuple and declares the bitwise components inside a word.",
          "createdAt": "2025-11-27T22:38:17Z",
          "updatedAt": "2025-11-28T07:37:16Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOONqYn87a8BHB",
      "title": "Companion Spec: Relations and Identity",
      "url": "https://github.com/json-structure/core/issues/17",
      "state": "OPEN",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Summary\n\nBased on the discussion in PR #8, propose a companion specification for modeling relationships/associations between objects in JSON Structure.\n\n## Proposal\n\nFor objects and tuples, add a new keyword `relations` that is similar to `properties` but specifically defines relationship properties. `relations` and `properties` share a namespace, so they can't define conflicting names.\n\nThe `relations` declarations are not modeled as types, because they must be able to cross-reference properties within the same tuple/object. They are similar to properties in that they are represented just like properties in the instances.\n\nA `relation` is a named object (via the `relations` map) that has two properties:\n\n- `targettype` - declares the target type that the relation refers to\n- `cardinality` - declares whether the relationship points to one or more targets (`single` or `multiple`)\n\nThe targettype's `identity` declaration functions like the `tuple` keyword for establishing the type of references, meaning that if the target's `identity` clause references two properties, the reference value in the relation source is a tuple-encoded list of values matching that identity.\n\n### Relation Instance Structure\n\nAn instance of a single relation is an object with the following properties:\n\n- `ref` - a JSON pointer to the target object\n- `identity` - a tuple that reflects the target object identity values\n\nA relationship MAY be established either through a direct link (ref) or through an `identity` match against all known instances of the target type.\n\n### Qualifier Support\n\nRelations can also support qualifiers (like link properties in a graph):\n\n- `qualifiertype` - defines/references a type to qualify the relationship further\n\n## Example Schema\n\n```json\n{\n  \"definitions\": {\n    \"Library\": {\n      \"Author\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\":   { \"type\": \"uuid\" },\n          \"name\": { \"type\": \"string\" }\n        },\n        \"required\": [\"id\", \"name\"],\n        \"identity\": [\"id\"]\n      },\n      \"Book\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"isbn\":  { \"type\": \"string\" },\n          \"title\": { \"type\": \"string\" }\n        },\n        \"required\": [\"isbn\", \"title\"],\n        \"identity\": [\"isbn\"],\n        \"relations\": {\n          \"authors\": {\n            \"cardinality\": \"multiple\",\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## References\n\n- PR #8: https://github.com/json-structure/core/pull/8\n- Issue #4: https://github.com/json-structure/core/issues/4\n- Discussion: https://github.com/json-structure/core/pull/8#discussion_r2179789408\n\ncc @Fannon",
      "createdAt": "2025-11-27T22:46:17Z",
      "updatedAt": "2025-11-27T22:46:17Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOONqYn87bJpSk",
      "title": "Allow \\ to accept an array of JSON Pointers for multiple inheritance",
      "url": "https://github.com/json-structure/core/issues/18",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Summary\r\n\r\nCurrently, the `$extends` keyword only accepts a single JSON Pointer to an abstract type (Section 3.10.2):\r\n\r\n> **Value:** A JSON Pointer to an abstract type.\r\n\r\nThis proposal suggests extending `$extends` to also accept an array of JSON Pointers, enabling multiple inheritance from several abstract base types.\r\n\r\n## Motivation\r\n\r\nWhen converting from other schema languages (e.g., CDDL with its unwrap operator `~`), it's common to compose types from multiple base groups:\r\n\r\n```cddl\r\nbase-header = (\r\n    version: uint,\r\n    timestamp: uint\r\n)\r\n\r\nmetadata = (\r\n    created: uint,\r\n    modified: uint\r\n)\r\n\r\nfull-record = {\r\n    ~base-header,\r\n    ~metadata,\r\n    data: bstr\r\n}\r\n```\r\n\r\nCurrently, JSON Structure cannot directly represent this pattern. The converter must either:\r\n1. Only use the first base type and lose information\r\n2. Inline all properties from additional base types (losing the inheritance relationship)\r\n\r\n## Proposed Change\r\n\r\nAllow `$extends` to accept either:\r\n- A single JSON Pointer (current behavior): `\"$extends\": \"#/definitions/BaseType\"`\r\n- An array of JSON Pointers: `\"$extends\": [\"#/definitions/BaseType1\", \"#/definitions/BaseType2\"]`\r\n\r\nExample:\r\n```json\r\n{\r\n  \"type\": \"object\",\r\n  \"name\": \"FullRecord\",\r\n  \"$extends\": [\"#/definitions/BaseHeader\", \"#/definitions/Metadata\"],\r\n  \"properties\": {\r\n    \"data\": { \"type\": \"binary\" }\r\n  }\r\n}\r\n```\r\n\r\n## Collision Resolution\r\n\r\nWhen multiple base types define properties with the same name, a resolution rule is needed. Suggested approach:\r\n\r\n1. **First-wins**: Properties from earlier types in the array take precedence (simple, predictable)\r\n2. **Last-wins**: Properties from later types override earlier ones (similar to many OOP languages)\r\n3. **Error**: Require explicit redefinition in the extending type to resolve conflicts\r\n\r\nRecommendation: **First-wins** for simplicity and consistency with the existing union type matching rule (\"the first matching type\").\r\n\r\n## Compatibility\r\n\r\nThis is a backward-compatible extension:\r\n- Existing schemas with single `$extends` values continue to work unchanged\r\n- Only schemas explicitly using array syntax would leverage the new behavior\r\n\r\n## Related\r\n\r\nThis issue was identified while implementing CDDL-to-JSON-Structure conversion in [avrotize](https://github.com/clemensv/avrotize/pull/114).\r\n",
      "createdAt": "2025-11-29T13:01:38Z",
      "updatedAt": "2025-11-29T16:59:06Z",
      "closedAt": "2025-11-29T16:59:06Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOONqYn87bUYoO",
      "title": "Spec Bug: Inconsistent $ref usage rules in examples",
      "url": "https://github.com/json-structure/core/issues/21",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Summary\n\nThe spec contains contradictory guidance on where `$ref` is permitted. Section 3.4.1 states `$ref` is **only** permitted inside the `type` attribute, but examples throughout the spec show bare `$ref` usage in `items`, `values`, and `choices`.\n\n## The Rule (Section 3.4.1 - $ref Keyword)\n\n> \"The $ref keyword is only permitted inside the \\type\\ attribute value of a schema definition, including in type unions.\"\n> \"$ref is NOT permitted in other attributes...\"\n\n## Contradicting Examples in the Spec\n\n### 1. Array `items` - CONSISTENT \n~~~json\n{\n  \"type\": \"array\",\n  \"items\": { \"type\": { \"$ref\": \"#/Namespace/TypeName\" } }\n}\n~~~\n\n### 2. Set `items` - INCONSISTENT \n~~~json\n{\n  \"type\": \"set\",\n  \"items\": { \"$ref\": \"#/Namespace/TypeName\" }\n}\n~~~\nShould be: `\"items\": { \"type\": { \"\\\": \"#/Namespace/TypeName\" } }`\n\n### 3. Map `values` - INCONSISTENT \n~~~json\n{\n  \"type\": \"map\",\n  \"values\": { \"$ref\": \"#/StringType\" }\n}\n~~~\nShould be: `\"values\": { \"type\": { \"\\\": \"#/StringType\" } }`\n\n### 4. Choice `choices` - INCONSISTENT \n~~~json\n{\n  \"type\": \"choice\",\n  \"choices\": {\n    \"StreetAddress\": { \"$ref\": \"#/definitions/StreetAddress\" },\n    \"PostOfficeBoxAddress\": { \"$ref\": \"#/definitions/PostOfficeBoxAddress\" }\n  }\n}\n~~~\nShould be: `\"StreetAddress\": { \"type\": { \"$ref\": \"#/definitions/StreetAddress\" } }`\n\n## Affected Spec Sections\n\n- Line 580: `set` example with bare $ref\n- Line 606: `map` example with bare $ref\n- Lines 738-739: `choice` example with bare $ref\n\n## Recommendation\n\nEither:\n\n1. **Update the rule** to explicitly allow bare ~~~ in `items`, `values`, and `choices` as a shorthand, OR\n2. **Update all examples** to use `{ \"type\": { \"$ref\": \"...\" } }` consistently\n\nOption 1 seems more ergonomic since these contexts unambiguously expect a type reference.\n\n## Impact\n\nSDK implementations are confused about whether to accept bare $ref in these contexts.",
      "createdAt": "2025-12-01T06:59:22Z",
      "updatedAt": "2025-12-01T07:35:25Z",
      "closedAt": "2025-12-01T07:35:25Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOONqYn86SnC9e",
      "title": "Introducing choice type",
      "url": "https://github.com/json-structure/core/pull/1",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This edit introduces the choice type for discriminated unions.",
      "createdAt": "2025-04-15T06:40:40Z",
      "updatedAt": "2025-04-22T11:20:16Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "b0c1472fb4714d8805af0f92659f2538d9e5ee03",
      "headRepository": "json-structure/core",
      "headRefName": "add-choice",
      "headRefOid": "ebea75e6290da25d1e91f5fdd22e76516564a858",
      "closedAt": "2025-04-22T11:20:12Z",
      "mergedAt": "2025-04-22T11:20:11Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "8f83b3da08ff5e86d8fe3566ed501f34ba58fcd6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOONqYn86UWdJa",
      "title": "Add id keyword to objects to state primary IDs",
      "url": "https://github.com/json-structure/core/pull/7",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nThis adds just the `id` keyword. \r\n\r\nThere will be another PR to also add the `targettype` keyword on property level. ",
      "createdAt": "2025-04-29T13:35:39Z",
      "updatedAt": "2025-07-03T05:55:34Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-id-keyword",
      "headRefOid": "240f7c05cbb9a898b10161c838bff9276682ed81",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nG6d2",
          "commit": {
            "abbreviatedOid": "0bff4c8"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:42:26Z",
          "updatedAt": "2025-04-29T13:42:27Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe `id` MUST only be used on objects.\r\nThe value MUST be an array of property names of the current object.\r\n```",
              "createdAt": "2025-04-29T13:42:26Z",
              "updatedAt": "2025-04-29T13:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHVol",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:59:11Z",
          "updatedAt": "2025-04-29T13:59:11Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Maybe more explicit:\r\n\r\n```suggestion\r\n              \"primaryid\": [\"ID\"],\r\n```",
              "createdAt": "2025-04-29T13:59:11Z",
              "updatedAt": "2025-04-29T13:59:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xiFYO",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@Fannon Let me know whether you can still adapt this; otherwise I can take this one over.",
          "createdAt": "2025-07-02T09:49:30Z",
          "updatedAt": "2025-07-02T09:57:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "\"identity\" will be clearer",
              "createdAt": "2025-07-02T09:49:30Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 6,
              "body": "objects and tuples.",
              "createdAt": "2025-07-02T09:49:46Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 7,
              "body": "lists the properties, in the role of identifiers,  that establish an unambiguous identity of an instance. Providing more than one property reference indicates a composite identity, not a list of alternate identifiers.",
              "createdAt": "2025-07-02T09:53:21Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 21,
              "body": "\"identity \" should be clear.",
              "createdAt": "2025-07-02T09:53:53Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 31,
              "body": "Identity SHOULD be used on object and tuple declarations. I assume the reason why you want to make it mandatory is the association feature, but I think that will just not work when there is no identity and that might be okay. ",
              "createdAt": "2025-07-02T09:56:18Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjJcz",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:27:58Z",
          "updatedAt": "2025-07-02T11:27:58Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Ah, I only wanted to make the statement that they must only be used on objects, but there they would be optional. \r\n\r\nI agree, they should be optional. Not every object may need an identity, e.g. value objects.",
              "createdAt": "2025-07-02T11:27:58Z",
              "updatedAt": "2025-07-02T11:27:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuvUN",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:53:12Z",
          "updatedAt": "2025-07-03T05:53:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe `id` keyword is only applicable on objects and tuples. It states the properties that\r\n```",
              "createdAt": "2025-07-03T05:53:12Z",
              "updatedAt": "2025-07-03T05:53:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuv1E",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:53:46Z",
          "updatedAt": "2025-07-03T05:55:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n              \"identity\": [\"ID\"],\r\n```",
              "createdAt": "2025-07-03T05:53:46Z",
              "updatedAt": "2025-07-03T05:55:34Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nAdding `identity` is optional, but only applicable on objects and tuples.\r\n```",
              "createdAt": "2025-07-03T05:55:29Z",
              "updatedAt": "2025-07-03T05:55:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOONqYn86UWuQU",
      "title": "Propose targettype keyword for associations",
      "url": "https://github.com/json-structure/core/pull/8",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nBuilds upon #7 \r\n\r\nAdds the `targettype` keyword to indicate associations / references / pointers within the model.",
      "createdAt": "2025-04-29T13:56:45Z",
      "updatedAt": "2025-07-03T05:52:37Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-targettype-keyword",
      "headRefOid": "8cbb31c63f96cd2934dec798d268dca2330067f9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think identities and relations would be a good companion spec. ",
          "createdAt": "2025-07-02T11:16:38Z",
          "updatedAt": "2025-07-02T11:16:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nHUsa",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:58:36Z",
          "updatedAt": "2025-04-29T13:58:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Other possible keyword names:\r\n\r\n```suggestion\r\n### `target` Keyword {#targettype-keyword}\r\n```\r\n\r\n```suggestion\r\n### `targetobject` Keyword {#targettype-keyword}\r\n```",
              "createdAt": "2025-04-29T13:58:37Z",
              "updatedAt": "2025-04-29T13:58:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHYCi",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T14:00:44Z",
          "updatedAt": "2025-04-29T14:00:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "@clemensv : Could it also appear in set and tuple?",
              "createdAt": "2025-04-29T14:00:44Z",
              "updatedAt": "2025-04-29T14:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjAp7",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:15:16Z",
          "updatedAt": "2025-07-02T11:15:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree with the direction of this, but I would make this broader:\r\n\r\nFor objects and tuples, I would add a new keyword \"relations\" that is similar to \"properties\" but specifically defines relationship properties. \"relations\" and \"properties\" share a namespace, so they can't define conflicting names.\r\n\r\nThe \"relations\" declarations are not modeled as types, because they must be able to cross-reference properties within the same tuple/object. They are similar to properties in that they are represented just like properties in the instances.\r\n\r\nA `relation` is a named object (via the `relations` map) that has two properties:\r\n\r\n- the `targettype` declares the target type that the relation refers to\r\n- the `cardinality` declares whether the relationship point to one or more targets\r\n\r\nthe targettype's `identity` declaration functions like the `tuple` keyword for establishing the type of references, meaning that if the target's `identity` clause references two properties, the reference value in the relation source is a tuple-encoded list of values matching that identity.\r\n\r\nAn instance of a single relation is an object with the following properties:\r\n\r\n\"ref\" : a JSON pointer to the target object\r\n\"identity\": a tuple that reflects the target object identity values\r\n\r\nA relationship MAY be established either through a direct link (ref) or through an `identity` match against all known instances of the target type. If both properties are defined, the `identity` match is performed against all instances of the target type that exists within the scope of the `ref` json pointer, i.e. are children of the identified node.\r\n\r\nthe value of relations with `multiple` cardinality is an array of such objects. the value of relations with `single` cardinality is a single such object.\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://json-structure.org/meta/core/v0/#\",\r\n  \"$id\":     \"https://example.com/library.schema\",\r\n  \"$root\":   \"#/definitions/Library/Document\",\r\n\r\n  \"definitions\": {\r\n    \"Library\": {\r\n\r\n      /* 1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  AUTHOR  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Author\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Author\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  PUBLISHER  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Publisher\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Publisher\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" },\r\n          \"city\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  BOOK  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Book\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Book\",\r\n\r\n        /* intrinsic fields only \u2014 reference\r\n           properties are implicit via `relations` */\r\n        \"properties\": {\r\n          \"isbn\":  { \"type\": \"string\" },\r\n          \"title\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"isbn\", \"title\"],\r\n        \"identity\": [\"isbn\"],\r\n\r\n        \"relations\": {\r\n          /* many Authors per Book  */\r\n          \"authors\": {\r\n            \"cardinality\": \"multiple\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n          /* exactly one Publisher per Book */\r\n          \"publisher\": {\r\n            \"cardinality\": \"single\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          }\r\n        }\r\n      },\r\n\r\n      /* 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  DOCUMENT ROOT  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Document\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"LibraryDocument\",\r\n        \"properties\": {\r\n          /* list of all authors present in this file */\r\n          \"authors\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n\r\n          /* list of all publishers */\r\n          \"publishers\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          },\r\n\r\n          /* list of all books */\r\n          \"books\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Book\" }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nInstance:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n  \"authors\": [\r\n    {\r\n      \"id\":   \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\",\r\n      \"name\": \"Brian W. Kernighan\"\r\n    },\r\n    {\r\n      \"id\":   \"b3e0fac1-603f-4960-8646-90b053b6af19\",\r\n      \"name\": \"Dennis M. Ritchie\"\r\n    }\r\n  ],\r\n  \"publishers\": [\r\n    {\r\n      \"id\":   \"9609d302-62fb-4d0a-9e71-86f744e3022c\",\r\n      \"name\": \"Prentice Hall\"\r\n    }\r\n  ],\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n      \"authors\": [\r\n        {\r\n          \"ref\":      \"#/authors/0\",\r\n          \"identity\": [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"]\r\n        },\r\n        {\r\n          \"ref\":      \"#/authors/1\",\r\n          \"identity\": [\"b3e0fac1-603f-4960-8646-90b053b6af19\"]\r\n        }\r\n      ],\r\n      \"publisher\": {\r\n        \"ref\":      \"#/publishers/0\",\r\n        \"identity\": [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nI explicitly made the `relation` instance an object, because that gives us the opportunity to declare a `qualifier` type in the `relation` which defines/references a type to qualify the relationship further, equivalent to link properties in a graph.\r\n\r\nExample:\r\n\r\nqualifier type:\r\n\r\n```\r\n\"AuthorRole\": {\r\n  \"type\": \"string\",\r\n  \"enum\": [\"Author\", \"Editor\", \"Illustrator\", \"Translator\"]\r\n}\r\n```\r\n\r\nextend the relation:\r\n\r\n```\r\n\"authors\": {\r\n  \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" },\r\n  \"cardinality\": \"multiple\",\r\n\r\n  /* NEW \u2013 the schema that qualifies the link                *\r\n   * Every relation-instance object MUST carry a `qualifier`  *\r\n   * that validates against this type.                       */\r\n  \"qualifiertype\": { \"$ref\": \"#/definitions/Library/AuthorRole\" }\r\n}\r\n```\r\n\r\nInstance with qualifiers:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n\r\n  \"authors\": [\r\n    { \"id\": \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\", \"name\": \"Brian W. Kernighan\" },\r\n    { \"id\": \"b3e0fac1-603f-4960-8646-90b053b6af19\", \"name\": \"Dennis M. Ritchie\" }\r\n  ],\r\n\r\n  \"publishers\": [\r\n    { \"id\": \"9609d302-62fb-4d0a-9e71-86f744e3022c\", \"name\": \"Prentice Hall\" }\r\n  ],\r\n\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n\r\n      \"authors\": [\r\n        {\r\n          \"ref\":       \"#/authors/0\",\r\n          \"identity\":  [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"],\r\n          \"qualifier\": \"Author\"          // \u2190 validated by AuthorRole enum\r\n        },\r\n        {\r\n          \"ref\":       \"#/authors/1\",\r\n          \"identity\":  [\"b3e0fac1-603f-4960-8646-90b053b6af19\"],\r\n          \"qualifier\": \"Author\"\r\n        }\r\n      ],\r\n\r\n      \"publisher\": {\r\n        \"ref\":       \"#/publishers/0\",\r\n        \"identity\":  [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n        /* no qualifier here because the relation         *\r\n         * lacks a `qualifiertype` in the declaration.    */\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n    ",
              "createdAt": "2025-07-02T11:15:16Z",
              "updatedAt": "2025-07-02T11:15:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuq6E",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:47:18Z",
          "updatedAt": "2025-07-03T05:47:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "You clarified it in another comment. \r\n\r\n```suggestion\r\nThe `targettype` is optional, but only applicable for object or tuple properties.\r\n```",
              "createdAt": "2025-07-03T05:47:18Z",
              "updatedAt": "2025-07-03T05:47:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuu1L",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:52:37Z",
          "updatedAt": "2025-07-03T05:52:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I like where this is going, thanks for creating this example! \r\nMoving it to its own `relation` property as an array of object seems like a really good idea. \r\n\r\nWhere I'm unsure is if we can assume that the instances are structured like you propose. I see how it's nice to make each reference an object and for convenience also adding a \"ref\", but in many real data cases I've seen the references are just a string property or an array of strings. The concept also needs to work with this. So the \"reference\" in the schema has to point to the property that carries the ID of the reference, too?\r\n\r\nLet me get back on this to you when I have more time to think it through. ",
              "createdAt": "2025-07-03T05:52:37Z",
              "updatedAt": "2025-07-03T05:52:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOONqYn86aktrc",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/pull/10",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #9\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-06-15T07:30:48Z",
      "updatedAt": "2025-06-15T07:32:21Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue9",
      "headRefOid": "bf4e6e8d219a8d636cbccaacee32e25df2a25fb1",
      "closedAt": "2025-06-15T07:32:12Z",
      "mergedAt": "2025-06-15T07:32:12Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOONqYn86dE9Wn",
      "title": "Clemensv/issue6",
      "url": "https://github.com/json-structure/core/pull/11",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #6\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-07-02T12:35:50Z",
      "updatedAt": "2025-07-02T12:36:11Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue6",
      "headRefOid": "cce9997c2154723262149595d31ab1ce561ae6cf",
      "closedAt": "2025-07-02T12:35:58Z",
      "mergedAt": "2025-07-02T12:35:58Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "4aeb7e24ee63935d52e768631e4f6c892851c19f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOONqYn861yhYq",
      "title": "Add integer type as alias for int32 (JSON Schema compatibility)",
      "url": "https://github.com/json-structure/core/pull/16",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Summary\n\nThis PR adds the `integer` type to the JSON Structure Core specification as an alias for `int32`.\n\n### Changes\n\n- Added `integer` type definition in the JSON Primitives section (after `number`)\n- The type is defined as an alias for `int32` with identical constraints\n- Updated the Type System Rules summary to include `integer` in the JSON Primitives list\n\n### Rationale\n\nThis addition provides compatibility with JSON Schema, which uses `integer` as a common type name. Having this alias allows easier migration from JSON Schema to JSON Structure.",
      "createdAt": "2025-11-27T07:28:33Z",
      "updatedAt": "2025-11-27T19:21:58Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "5c84ab7eb5eebe6908fc41104419f82d10f4b60b",
      "headRepository": "json-structure/core",
      "headRefName": "add-integer-type",
      "headRefOid": "05b5b7d38a65038fb8c86cd659d0581415a06b16",
      "closedAt": "2025-11-27T19:21:52Z",
      "mergedAt": "2025-11-27T19:21:52Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "b2db20efe006d6724d2af804152a632c53005359"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOONqYn862IlIK",
      "title": "Add uuidEncoding keyword for UUID encoding format selection",
      "url": "https://github.com/json-structure/core/pull/19",
      "state": "OPEN",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a new uuidEncoding type annotation keyword for the uuid type that allows specifying alternate UUID encoding formats.\n\n## Changes\n\n1. **Updated the uuid type definition** (Section 3.2.2.20) to reference the new uuidEncoding keyword for alternate encodings.\n\n2. **Added the uuidEncoding Keyword section** with the following permitted values:\n   - rfc9562: Standard RFC 9562 UUID format (default)\n   - base32hex: 26-character unpadded base32hex encoding (RFC 4648)\n   - base64: Base64 encoding (RFC 4648)\n   - base64url: Base64url encoding (RFC 4648)\n\n## Background\n\nAs discussed in #14, this implements a type qualifier approach to select the UUID encoding format, allowing for compact representations like base32hex while maintaining backward compatibility with the standard RFC 9562 format as the default.\n\nFixes #14",
      "createdAt": "2025-11-29T15:34:31Z",
      "updatedAt": "2025-11-29T15:44:50Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "b2db20efe006d6724d2af804152a632c53005359",
      "headRepository": "json-structure/core",
      "headRefName": "issue-14-uuid-encoding",
      "headRefOid": "2fda3ba92773dc23b18920967252e6a07aa924d4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOONqYn862InkN",
      "title": "Allow $extends to accept an array of JSON Pointers for multiple inheritance",
      "url": "https://github.com/json-structure/core/pull/20",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR extends the `\\$extends\\` keyword to support multiple inheritance by accepting an array of JSON Pointers.\r\n\r\n## Changes\r\n\r\n1. **Updated the `$extends` keyword value** to accept either:\r\n   - A single JSON Pointer (current behavior)\r\n   - An array of JSON Pointers (new)\r\n\r\n2. **Added collision resolution rule**: When multiple base types define properties with the same name, the property from the first base type in the array takes precedence (first-wins).\r\n\r\n3. **Added example** demonstrating multiple inheritance with \\\\\\BaseHeader\\\\\\ and \\\\\\Metadata\\\\\\ abstract types.\r\n\r\n## Motivation\r\n\r\nThis enables composition patterns common in other schema languages like CDDL, where types can be composed from multiple base groups using the unwrap operator (\\\\\\~\\\\\\).\r\n\r\n## Compatibility\r\n\r\nThis is backward-compatible:\r\n- Existing schemas with single \\\\\\\\\\\\\\ values continue to work unchanged\r\n- Only schemas explicitly using array syntax leverage the new behavior\r\n\r\nFixes #18",
      "createdAt": "2025-11-29T15:52:32Z",
      "updatedAt": "2025-11-29T16:59:12Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "b2db20efe006d6724d2af804152a632c53005359",
      "headRepository": "json-structure/core",
      "headRefName": "issue-18-extends-array",
      "headRefOid": "10fdabf87bd5575d04af04d72f81ed2d46295d02",
      "closedAt": "2025-11-29T16:59:05Z",
      "mergedAt": "2025-11-29T16:59:05Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "4b574796f054488d11e4ed8fed136697111afa01"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOONqYn862RoUt",
      "title": "Fix inconsistent  usage in examples (fixes #21)",
      "url": "https://github.com/json-structure/core/pull/22",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Summary\n\nThis PR fixes the inconsistent usage of $ref in examples throughout the spec, ensuring all examples comply with the rule stated in Section 3.4.1.\n\n## Changes\n\nUpdated examples to consistently use $ref only inside the \type attribute:\n\n1. **Set items example (line 580)**: Changed from bare $ref to { \"type\": { \"\": ... } }\n2. **Map values example (line 606)**: Changed from bare $ref to { \"type\": { \"\": ... } }\n3. **Choice choices examples (lines 738-739)**: Changed from bare $ref to { \"type\": { \"\": ... } }\n\n## Rationale\n\nSection 3.4.1 explicitly states:\n> \"The  keyword is only permitted inside the 'type' attribute value of a schema definition, including in type unions.\"\n> \" is NOT permitted in other attributes...\"\n\nThese changes ensure all examples follow this rule consistently.\n\nFixes #21\r\n",
      "createdAt": "2025-12-01T07:33:10Z",
      "updatedAt": "2025-12-01T07:35:29Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "4b574796f054488d11e4ed8fed136697111afa01",
      "headRepository": "json-structure/core",
      "headRefName": "fix/issue-21-ref-consistency",
      "headRefOid": "903969c397916945bbd55fc0291b3ac9f4a19304",
      "closedAt": "2025-12-01T07:35:24Z",
      "mergedAt": "2025-12-01T07:35:24Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "abefe4bc54a7cdfbf6b604b2cbcce428844f4608"
      },
      "comments": [],
      "reviews": []
    }
  ]
}