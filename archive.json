{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-11-11T00:45:01.662449+00:00",
  "repo": "json-structure/core",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "companion spec",
      "description": "candidate topic for a companion spec",
      "color": "a30bb9"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOONqYn86ztw5t",
      "title": "\"tuple\" type declaration of \"properties\" is problematic",
      "url": "https://github.com/json-structure/core/issues/2",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `properties` declaration is reused for the `tuple` type. That's an issue because the tuple is ordered and the `properties` declaration is an object where keys are unordered. \n\nI do like preserving the same declaration style as for `object` combined with the terseness of the encoding in an array.  \n\nNoting this as an issue while pondering the options.",
      "createdAt": "2025-04-23T19:55:26Z",
      "updatedAt": "2025-04-24T07:05:57Z",
      "closedAt": "2025-04-24T07:05:57Z",
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fix will be an ordering array that references the properties. The tuple still defines a data structure with property names such that it can be easily mapped to an object in a programming language or database.\n\n```\n{\n  \"type\": \"tuple\",\n  \"name\": \"Person\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"int32\" }\n  },\n  \"tuple\": [\"name\", \"age\"]\n}\n```",
          "createdAt": "2025-04-24T05:48:55Z",
          "updatedAt": "2025-04-24T05:48:55Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOONqYn86z9ZkN",
      "title": "Idea: Consider relaxing dict key charset restriction, rely on \"name\" instead of \"altnames.json\"",
      "url": "https://github.com/json-structure/core/issues/3",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just a suggestion / feedback on something that could be done *differently*, but the current proposal also works.\n\nInstead of applying the restricted charset ([Identifier Rules](https://json-structure.github.io/core/draft-vasters-json-structure-core.html#section-3.6)) to the dictionary keys AND to the `name`, we could make it more similar to how JSON Schema works today:\n\n- There are no limitation on dictionary key charset and it represents the JSON encoding name (`altnames.json`). If this contains restricted chars, it's mandatory to add `name` for codegen / tools.\n- The `altnames.json` can be removed, and it's not necessary to use a spec extension just to describe existing JSON / JS structures as they are.\n- Tools / codegens will always use `name` and fall back to the dictionary key.\n\nAdvantages from my view:\n- Closer to how JSON Schema works today\n- One less concept and one less spec extension to understand \n- I think that modeling existing JSON structures is very common, the new identifier name restrictions may only work consistently for greenfield / new models that are created in JSON Structure from start.\n\nDisadvantages:\n- Validation of correct JSON Structure document is more complicated, because the regexp validation on dictionary keys is conditional (only has to match regex if no `name` is provided).",
      "createdAt": "2025-04-25T07:21:44Z",
      "updatedAt": "2025-04-25T14:29:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The restriction of the character set of names is very intentional. I want to make sure that all names and namespaces can be cleanly mapped into databases and most common programming languages. Being able to define everyone's weird JSON document shapes is not a goal I am pursuing. altnames/json is a way to hack around that restriction and the pain of doing that is also intentional. \n\nthere are a few cases where \"name\" doesn't have a map above it and therefore this proposal would not work for those cases. ",
          "createdAt": "2025-04-25T11:18:15Z",
          "updatedAt": "2025-04-25T11:18:15Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "@clemensv - yes, I understood that and fully agree that this is useful. The charset restriction of `name` would stay exactly like it is. \n\nBut if `name` can't be put in every place where it's needed, this approach would cause issues. Where would this be? ",
          "createdAt": "2025-04-25T14:29:14Z",
          "updatedAt": "2025-04-25T14:29:20Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOONqYn86z9g6z",
      "title": "Feature: Support Associations",
      "url": "https://github.com/json-structure/core/issues/4",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In my experience, one of the biggest gaps of JSON Schema is that it's not possible to describe associations. Both IDs and associations are just \"string\" or maybe \"UUID\" format if you're lucky. This is probably due to JSON Schema only focusing on validation, not on describing models. \n\nJSON Structure is already much better suited to describe models, but it would be important to also explicitly model the associations, e.g. to express FK relationships in database schemas or references / associations in API models. \n\nThere are many ways to go about it, we could collect them here. \n\n### PRs\n\n- https://github.com/json-structure/core/pull/7\n- https://github.com/json-structure/core/pull/8\n\n### Initial Proposal\n\nA first initial, simpler proposal (partially discussed with Clemens) could look like this. \n\n- Add new structural keyword `id` to object and , which is an array of property names that are the \"primary ID\" that are used to reference to it. This is usually one value, but if its multiple, we have a \"composite ID\". \n- Add a new structural keyword `targettype` to properties, the value is a JSON Pointer to the association target object. The target MSUT be an object and MUST have use the `id` keyword.\n- Cardinality is known through `required` and whether the association is within an `array` or not.\n- We do not need a dedicated `association` type, because it's useful to know the type of the ID itself (could be string, UUID, number, ...). We know something is an ID, because we marked it with `id` and we know something is an association by having the `targettype` keyword in it.\n- Polymorphic associations could probably be covered by wrapping this into a `choice`. (@clemensv ?)\n\n### Gaps / Open Questions \n- For composite IDs and References, we still don't know which source object property maps to which target object property. If this is needed to understand (e.g. to automatically construct query join conditions or code that joins the associations), we need to define this mapping.\n  - Maybe we could add a `targetproperty` in this case, where the property name for the corresponding ID is stated. EDIT: This alone is not sufficient if one object has more than one association to the same target. In this case, it's necessary to know which properties on the source object together form one composite association to the target objects composite ID (and how the properties each map). \n- Not sure if we could also use `abstract` objects for polymorphic associations. In this case, you could point to the abstract object, it defines the shared `id`. All concrete implementations of the abstract object are then valid association targets. ",
      "createdAt": "2025-04-25T07:35:56Z",
      "updatedAt": "2025-04-29T13:57:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think of your proposal as three (!) features that compose:\n\n1) The `targettype` annotation for `jsonpointer` typed schemas simply creates a constraint for what JSON node the JSON Pointer may point at, nothing more. \n\n2) The optional, array-of-string valued `id` annotation for `object` (and `tuple`) establishes a set of identifiers that MUST, in combination, be unique for each instance. That is also a feature that puts a constraint on instances (the check will have to span instances of all usages of the type independent of where they appear in a document). \n\n3) If a `jsonpointer` points from some type property to another `targettype`, and that `targettype` has a declared `id`, a mapping into a database can use that information to construct a foreign key relationship. If there are mutual relationships, of that sort, that may cause an extra table to be created. That's basically a side-product of 1) and 2). \n\nPolymorphic associations would point to a `choice`, yes. For an inline discriminator `choice`, the base class would have to define the `id` already.",
          "createdAt": "2025-04-25T09:25:48Z",
          "updatedAt": "2025-04-25T09:25:48Z"
        },
        {
          "author": "Fannon",
          "authorAssociation": "NONE",
          "body": "Yes, it makes sense to compose it to separate feature requests / PRs. Maybe an additional one to support composite IDs via `targetproperty` (or something else) - but that is not needed for a first iteration.\n\nThose 2 first features could be separate PRs (should I create them?) and work together to get the associations as a feature into JSON Structure.\n\nFeature 3 is then more of a implication?",
          "createdAt": "2025-04-25T09:28:37Z",
          "updatedAt": "2025-04-25T09:45:33Z"
        },
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, 3 is a result of 1 and 2. If you want to create PRs, go right ahead!",
          "createdAt": "2025-04-25T21:00:24Z",
          "updatedAt": "2025-04-25T21:00:24Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOONqYn860GhWp",
      "title": "Section 3.8 - Prohibit type annotations with type unions",
      "url": "https://github.com/json-structure/core/issues/5",
      "state": "OPEN",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a clause that explicitly prohibits using type annotations in schemas where the type is a type-union.\n\nThis prevents ambiguous definitions where the type union includes a combination of types (e.g. [\"string\", \"decimal\"]) and the annotation would only apply to  one of the types.\n\nTo achieve a type union of further constrained types, one must define them as reusable types and type-union those.\n\nThe prohibition will also extend to and be repeated in the validation spec.",
      "createdAt": "2025-04-26T08:04:18Z",
      "updatedAt": "2025-04-26T08:04:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOONqYn860exCx",
      "title": "Clarify encoding of `$ref`",
      "url": "https://github.com/json-structure/core/issues/6",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "The JSON Pointer for `$ref` is encoded with a leading '#' and thus leans on RFC6901 Section 6 to ease composition for deep-links; that's not noted in the draft at the moment and should be. ",
      "createdAt": "2025-04-29T11:25:17Z",
      "updatedAt": "2025-07-02T12:36:00Z",
      "closedAt": "2025-07-02T12:36:00Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOONqYn867lmws",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/issues/9",
      "state": "CLOSED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "clemensv"
      ],
      "labels": [],
      "body": "`map` keys are currently restricted to the identifier character set. Since `map` keys are unlikely to be mapped to column names or variable names while projecting a JSON Structure onto a database or programming language, we can lift the restriction.",
      "createdAt": "2025-06-15T07:15:36Z",
      "updatedAt": "2025-06-15T07:32:13Z",
      "closedAt": "2025-06-15T07:32:12Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOONqYn87Cgvd-",
      "title": "Compare to JSON-Schema.org",
      "url": "https://github.com/json-structure/core/issues/12",
      "state": "OPEN",
      "author": "aurium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Don't get me wrong. I thought this was great!\nWhoever, I think you could put it clearly somewhere:\n\n  * Why JSON Structure when you have other mature alternatives?\n  * Where JSON Structure differs to JSON Schema?\n  * In what cases is this superior to JSON Schema?\n",
      "createdAt": "2025-07-25T14:10:16Z",
      "updatedAt": "2025-08-13T14:46:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The primer aims to provide that: https://github.com/json-structure/primer-and-samples/blob/main/json-structure-primer.md",
          "createdAt": "2025-08-13T14:46:41Z",
          "updatedAt": "2025-08-13T14:46:41Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOONqYn87HE52k",
      "title": "Relationship to RFC 8927 (JSON Type Definition)?",
      "url": "https://github.com/json-structure/core/issues/13",
      "state": "OPEN",
      "author": "gsnedders",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [primer](https://github.com/json-structure/primer-and-samples/blob/main/json-structure-primer.md) says:\n\n> There are rapidly growing needs for a standardized (IETF RFC) schema language that can describe data types and structures and whose definitions map cleanly to programming language types and database constructs as well as into the popular JSON data encoding.\n\nIt goes on to talk about JSON Schema.\n\nHowever, it doesn't mention RFC 8927 (JSON Type Definition) whatsoever, which is already a published RFC.",
      "createdAt": "2025-08-21T01:22:20Z",
      "updatedAt": "2025-08-21T01:22:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOONqYn87RN51y",
      "title": "New base32hex 26-character unpadded format for UUID",
      "url": "https://github.com/json-structure/core/issues/14",
      "state": "OPEN",
      "author": "sergeyprokhorenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It is necessary to expand the wording:\n\n3.2.2.20. uuid\nA universally unique identifier.\u00b6\n* Base type: string\u00b6\n* Constraints:\u00b6\n    * The string value MUST conform to the [RFC9562] UUID format **or [RFC4648] base32hex 26-character unpadded format.\u00b6**\n\nSee https://github.com/x4m/postgres_g/commit/aa902bbc5dfc47d4b35f05016304a1e671abb505",
      "createdAt": "2025-10-13T13:29:11Z",
      "updatedAt": "2025-10-13T13:57:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOONqYn87W4iAS",
      "title": "Proposal for flexible numeric types inspired by the ADA type system",
      "url": "https://github.com/json-structure/core/issues/15",
      "state": "OPEN",
      "author": "ThyMYthOS",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "### Proposal for a More Flexible Numeric Type System\n\nFirst, thank you for the work on this draft. The clear and strict type system is a great foundation.\n\nThis proposal suggests enhancing the numeric type system to be more flexible and descriptive, allowing for the precise definition of numeric types with arbitrary precision, particularly for scientific, financial, and hardware-interfacing applications.\n\n### Current State\n\nThe current specification defines a useful set of fixed-size numeric types (`int8`...`int128`, `float`, `double`) and a `decimal` type for high precision. It also lists `precision` and `scale` as annotation keywords (3.8.2, 3.8.3).\n\nHowever, this system could be made more expressive. For example, it's not explicitly clear how to define:\n\n- A floating-point number with a minimum required decimal precision (not just float or double).\n- A binary fixed-point number with a specific delta (absolute error).\n- A decimal fixed-point number (which decimal + precision + scale may cover, but could be more explicit).\n- A modular (wrap-around) integer type, common in many systems.\n\n### Inspiration: The ADA Type System\n\nThe ADA language provides an excellent model for defining numeric types based on their requirements rather than their implementation. This makes schemas more portable and semantically rich.\n\nWe could adopt a similar model by clarifying and extending the use of the precision and scale keywords, and perhaps introducing a new keyword like model to define the numeric representation.\n\nThis proposal suggests an approach that:\n * Uses the standard type property (\"number\" or \"string\") to define the storage representation of the value in the JSON document.\n * Adds new \"qualifier\" properties (e.g., `representation`, `radix`) at the same level as type to specify the exact semantics.\nThe type is set to `\"number\"` if the value can be losslessly represented by a standard JSON number (IEEE 754 double). Otherwise, type is set to `\"string\"` to hold the high-precision value.\n\n**Proposed Properties**\n * `type`: `\"number\"` | `\"string\"` _(Required)_\n * `representation`: `\"integer\"` | `\"floating\"` | `\"fixed\"` | `\"rational\"` | `\"modular\"` _(Required for this proposal)_\n * `radix`: `\"binary\"` | `\"decimal\"` _(Required for integer, fixed, and floating)_\n * `precision`: `integer` _(Optional. The number of significant bits/digits)_\n   * For integer and fixed: The total number of bits (if radix: \"binary\") or digits (if radix: \"decimal\").\n   * For floating: The number of bits (if radix: \"binary\") or digits (if radix: \"decimal\") in the mantissa.\n * `scale`: `integer` _(Optional. Required for fixed representation. The number of fractional bits/digits)._\n * `modulus`: `string` | `number` _(Optional. Required for modular representation. Same type as indicated by `type`)._\n * `minimum`: `string` | `number` _(Optional. The inclusive minimum valid value, as a string for arbitrary precision)._\n * `maximum`: `string` | `number` _(Optional. The inclusive maximum valid value, as a string for arbitrary precision)._\n * `exclusiveMinimum`: `string` | `number` _(Optional. The exclusive minimum valid value, as a string for arbitrary precision)._\n * `exclusiveMaximum`: `string` | `number` _(Optional. The exclusive maximum valid value, as a string for arbitrary precision)._\n\n### Relationship to Current Definitions\nThis proposal can be seen as a superset of the numeric types currently defined in the JSON Structure Core draft (e.g., uint8, int32, float64).\nThose definitions can be expressed using this proposal:\n * uint8:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 8,\n  \"minimum\": \"0\",\n  \"exclusiveMaximum\": \"256\"\n```\n * int32:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 32,\n  \"minimum\": \"-2147483648\",\n  \"exclusiveMaximum\": \"2147483648\"\n```\n * float64 (IEEE 754 Double):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"floating\",\n  \"radix\": \"binary\",\n  \"precision\": 53,\n  \"minimum\": \"-1.7976931348623157e+308\",\n  \"maximum\": \"1.7976931348623157e+308\"\n```\n   _(Note: precision is 53 for the bits in the mantissa. Inclusive min/max is standard for float definitions)._\n\nThe key limitation of the current definitions is that they are restricted to power-of-two, binary types. This proposal extends support to:\n * Non-power-of-two binary types: e.g., a 10-bit integer from a sensor.\n * Decimal types: e.g., DECIMAL(19, 4) for finance, which cannot be losslessly represented by float64.\nThis proposal provides a single, unified system for defining all of them.\n\n### Examples\nHere is how this system would define various numeric types.\n1. Binary Integer\n * Concept: A base-2 integer.\n * Schema (for uint10 sensor reading):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 10,\n  \"minimum\": 0,\n  \"exclusiveMaximum\": 1024\n ```\n * Schema (for int128):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"integer\",\n  \"radix\": \"binary\",\n  \"precision\": 128,\n  \"minimum\": \"-170141183460469231731687303715884105728\",\n  \"exclusiveMaximum\": \"170141183460469231731687303715884105728\"\n```\n2. Binary Floating Point\n * Concept: A base-2 floating-point number.\n * Schema (for binary64/double):\n   * (See \"Relationship to Current Definitions\" section)\n * Schema (for arbitrary 512-bit float):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"floating\",\n  \"radix\": \"binary\",\n  \"precision\": 450\n```\n3. Binary Fixed Point\n * Concept: A base-2 fixed-point number (e.g., Q notation).\n * Schema (for Q24.8, 32-bit total):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"fixed\",\n  \"radix\": \"binary\",\n  \"precision\": 32,\n  \"scale\": 8,\n  \"minimum\": -8388608,\n  \"exclusiveMaximum\": 8388608\n```\n4. Decimal Floating Point\n * Concept: A base-10 floating-point number.\n * Schema (for decimal128, 34-digit mantissa):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"floating\",\n  \"radix\": \"decimal\",\n  \"precision\": 34\n```\n5. Decimal Fixed Point\n * Concept: Standard for currency (DECIMAL(p, s)).\n * Schema (for DECIMAL(19, 4)):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"fixed\",\n  \"radix\": \"decimal\",\n  \"precision\": 19,\n  \"scale\": 4,\n  \"exclusiveMinimum\": \"-1000000000000000\",\n  \"exclusiveMaximum\": \"1000000000000000\"\n```\n * Schema (for DECIMAL(10, 2)):\n ```json\n  \"type\": \"number\",\n  \"representation\": \"fixed\",\n  \"radix\": \"decimal\",\n  \"precision\": 10,\n  \"scale\": 2,\n  \"exclusiveMinimum\": -100000000,\n  \"exclusiveMaximum\": 100000000\n```\n6. Rational Numbers\n * Concept: A number as a ratio of two integers.\n * Schema:\n ```json\n  \"type\": \"string\",\n  \"representation\": \"rational\"\n```\n7. Modular Types\n * Concept: An integer that wraps around.\n * Schema (for mod 360), e.g. heading in degrees:\n ```json\n  \"type\": \"number\",\n  \"representation\": \"modular\",\n  \"modulus\": \"360\"\n```\n * Schema (for mod 2**256):\n ```json\n  \"type\": \"string\",\n  \"representation\": \"modular\",\n  \"modulus\": \"115792089237316195423570985008687907853269984665640564039457584007913129639936\",\n  \"minimum\": \"0\",\n  \"exclusiveMaximum\": \"115792089237316195423570985008687907853269984665640564039457584007913129639936\"\n```\n\n### Benefits of This Approach\n * Backwards-Compatible: Parsers that don't understand the new properties still see a valid JSON type (`\"number\"` or `\"string\"`).\n * Explicit Storage: Clearly separates the logical numeric type from its physical storage in the JSON document.\n * Unambiguous Deserialization: A consumer knows whether to parse a value from a string or use the native number, and knows what precise data type (e.g., `Decimal`, `BigInt`) to deserialize it into.\n * Extensible: Unifies all numeric types (current and future) under one flexible system.",
      "createdAt": "2025-11-09T15:55:22Z",
      "updatedAt": "2025-11-09T15:55:22Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOONqYn86SnC9e",
      "title": "Introducing choice type",
      "url": "https://github.com/json-structure/core/pull/1",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This edit introduces the choice type for discriminated unions.",
      "createdAt": "2025-04-15T06:40:40Z",
      "updatedAt": "2025-04-22T11:20:16Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "b0c1472fb4714d8805af0f92659f2538d9e5ee03",
      "headRepository": "json-structure/core",
      "headRefName": "add-choice",
      "headRefOid": "ebea75e6290da25d1e91f5fdd22e76516564a858",
      "closedAt": "2025-04-22T11:20:12Z",
      "mergedAt": "2025-04-22T11:20:11Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "8f83b3da08ff5e86d8fe3566ed501f34ba58fcd6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOONqYn86UWdJa",
      "title": "Add id keyword to objects to state primary IDs",
      "url": "https://github.com/json-structure/core/pull/7",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nThis adds just the `id` keyword. \r\n\r\nThere will be another PR to also add the `targettype` keyword on property level. ",
      "createdAt": "2025-04-29T13:35:39Z",
      "updatedAt": "2025-07-03T05:55:34Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-id-keyword",
      "headRefOid": "240f7c05cbb9a898b10161c838bff9276682ed81",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nG6d2",
          "commit": {
            "abbreviatedOid": "0bff4c8"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:42:26Z",
          "updatedAt": "2025-04-29T13:42:27Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe `id` MUST only be used on objects.\r\nThe value MUST be an array of property names of the current object.\r\n```",
              "createdAt": "2025-04-29T13:42:26Z",
              "updatedAt": "2025-04-29T13:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHVol",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:59:11Z",
          "updatedAt": "2025-04-29T13:59:11Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Maybe more explicit:\r\n\r\n```suggestion\r\n              \"primaryid\": [\"ID\"],\r\n```",
              "createdAt": "2025-04-29T13:59:11Z",
              "updatedAt": "2025-04-29T13:59:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xiFYO",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@Fannon Let me know whether you can still adapt this; otherwise I can take this one over.",
          "createdAt": "2025-07-02T09:49:30Z",
          "updatedAt": "2025-07-02T09:57:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "\"identity\" will be clearer",
              "createdAt": "2025-07-02T09:49:30Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 6,
              "body": "objects and tuples.",
              "createdAt": "2025-07-02T09:49:46Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 7,
              "body": "lists the properties, in the role of identifiers,  that establish an unambiguous identity of an instance. Providing more than one property reference indicates a composite identity, not a list of alternate identifiers.",
              "createdAt": "2025-07-02T09:53:21Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 21,
              "body": "\"identity \" should be clear.",
              "createdAt": "2025-07-02T09:53:53Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            },
            {
              "originalPosition": 31,
              "body": "Identity SHOULD be used on object and tuple declarations. I assume the reason why you want to make it mandatory is the association feature, but I think that will just not work when there is no identity and that might be okay. ",
              "createdAt": "2025-07-02T09:56:18Z",
              "updatedAt": "2025-07-02T09:57:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjJcz",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:27:58Z",
          "updatedAt": "2025-07-02T11:27:58Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Ah, I only wanted to make the statement that they must only be used on objects, but there they would be optional. \r\n\r\nI agree, they should be optional. Not every object may need an identity, e.g. value objects.",
              "createdAt": "2025-07-02T11:27:58Z",
              "updatedAt": "2025-07-02T11:27:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuvUN",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:53:12Z",
          "updatedAt": "2025-07-03T05:53:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe `id` keyword is only applicable on objects and tuples. It states the properties that\r\n```",
              "createdAt": "2025-07-03T05:53:12Z",
              "updatedAt": "2025-07-03T05:53:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuv1E",
          "commit": {
            "abbreviatedOid": "240f7c0"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:53:46Z",
          "updatedAt": "2025-07-03T05:55:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n              \"identity\": [\"ID\"],\r\n```",
              "createdAt": "2025-07-03T05:53:46Z",
              "updatedAt": "2025-07-03T05:55:34Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nAdding `identity` is optional, but only applicable on objects and tuples.\r\n```",
              "createdAt": "2025-07-03T05:55:29Z",
              "updatedAt": "2025-07-03T05:55:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOONqYn86UWuQU",
      "title": "Propose targettype keyword for associations",
      "url": "https://github.com/json-structure/core/pull/8",
      "state": "OPEN",
      "author": "Fannon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "companion spec"
      ],
      "body": "Relates #4 \r\n\r\nBuilds upon #7 \r\n\r\nAdds the `targettype` keyword to indicate associations / references / pointers within the model.",
      "createdAt": "2025-04-29T13:56:45Z",
      "updatedAt": "2025-07-03T05:52:37Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "Fannon/json-structure-core",
      "headRefName": "add-targettype-keyword",
      "headRefOid": "8cbb31c63f96cd2934dec798d268dca2330067f9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think identities and relations would be a good companion spec. ",
          "createdAt": "2025-07-02T11:16:38Z",
          "updatedAt": "2025-07-02T11:16:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOONqYn86nHUsa",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T13:58:36Z",
          "updatedAt": "2025-04-29T13:58:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Other possible keyword names:\r\n\r\n```suggestion\r\n### `target` Keyword {#targettype-keyword}\r\n```\r\n\r\n```suggestion\r\n### `targetobject` Keyword {#targettype-keyword}\r\n```",
              "createdAt": "2025-04-29T13:58:37Z",
              "updatedAt": "2025-04-29T13:58:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86nHYCi",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T14:00:44Z",
          "updatedAt": "2025-04-29T14:00:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "@clemensv : Could it also appear in set and tuple?",
              "createdAt": "2025-04-29T14:00:44Z",
              "updatedAt": "2025-04-29T14:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xjAp7",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "clemensv",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-02T11:15:16Z",
          "updatedAt": "2025-07-02T11:15:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree with the direction of this, but I would make this broader:\r\n\r\nFor objects and tuples, I would add a new keyword \"relations\" that is similar to \"properties\" but specifically defines relationship properties. \"relations\" and \"properties\" share a namespace, so they can't define conflicting names.\r\n\r\nThe \"relations\" declarations are not modeled as types, because they must be able to cross-reference properties within the same tuple/object. They are similar to properties in that they are represented just like properties in the instances.\r\n\r\nA `relation` is a named object (via the `relations` map) that has two properties:\r\n\r\n- the `targettype` declares the target type that the relation refers to\r\n- the `cardinality` declares whether the relationship point to one or more targets\r\n\r\nthe targettype's `identity` declaration functions like the `tuple` keyword for establishing the type of references, meaning that if the target's `identity` clause references two properties, the reference value in the relation source is a tuple-encoded list of values matching that identity.\r\n\r\nAn instance of a single relation is an object with the following properties:\r\n\r\n\"ref\" : a JSON pointer to the target object\r\n\"identity\": a tuple that reflects the target object identity values\r\n\r\nA relationship MAY be established either through a direct link (ref) or through an `identity` match against all known instances of the target type. If both properties are defined, the `identity` match is performed against all instances of the target type that exists within the scope of the `ref` json pointer, i.e. are children of the identified node.\r\n\r\nthe value of relations with `multiple` cardinality is an array of such objects. the value of relations with `single` cardinality is a single such object.\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://json-structure.org/meta/core/v0/#\",\r\n  \"$id\":     \"https://example.com/library.schema\",\r\n  \"$root\":   \"#/definitions/Library/Document\",\r\n\r\n  \"definitions\": {\r\n    \"Library\": {\r\n\r\n      /* 1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  AUTHOR  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Author\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Author\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  PUBLISHER  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Publisher\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Publisher\",\r\n        \"properties\": {\r\n          \"id\":   { \"type\": \"uuid\" },\r\n          \"name\": { \"type\": \"string\" },\r\n          \"city\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"id\", \"name\"],\r\n        \"identity\": [\"id\"]\r\n      },\r\n\r\n      /* 3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  BOOK  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Book\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"Book\",\r\n\r\n        /* intrinsic fields only \u2014 reference\r\n           properties are implicit via `relations` */\r\n        \"properties\": {\r\n          \"isbn\":  { \"type\": \"string\" },\r\n          \"title\": { \"type\": \"string\" }\r\n        },\r\n        \"required\": [\"isbn\", \"title\"],\r\n        \"identity\": [\"isbn\"],\r\n\r\n        \"relations\": {\r\n          /* many Authors per Book  */\r\n          \"authors\": {\r\n            \"cardinality\": \"multiple\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n          /* exactly one Publisher per Book */\r\n          \"publisher\": {\r\n            \"cardinality\": \"single\",\r\n            \"targettype\":  { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          }\r\n        }\r\n      },\r\n\r\n      /* 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  DOCUMENT ROOT  \u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\r\n      \"Document\": {\r\n        \"type\": \"object\",\r\n        \"name\": \"LibraryDocument\",\r\n        \"properties\": {\r\n          /* list of all authors present in this file */\r\n          \"authors\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Author\" }\r\n          },\r\n\r\n          /* list of all publishers */\r\n          \"publishers\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Publisher\" }\r\n          },\r\n\r\n          /* list of all books */\r\n          \"books\": {\r\n            \"type\": \"array\",\r\n            \"items\": { \"$ref\": \"#/definitions/Library/Book\" }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nInstance:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n  \"authors\": [\r\n    {\r\n      \"id\":   \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\",\r\n      \"name\": \"Brian W. Kernighan\"\r\n    },\r\n    {\r\n      \"id\":   \"b3e0fac1-603f-4960-8646-90b053b6af19\",\r\n      \"name\": \"Dennis M. Ritchie\"\r\n    }\r\n  ],\r\n  \"publishers\": [\r\n    {\r\n      \"id\":   \"9609d302-62fb-4d0a-9e71-86f744e3022c\",\r\n      \"name\": \"Prentice Hall\"\r\n    }\r\n  ],\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n      \"authors\": [\r\n        {\r\n          \"ref\":      \"#/authors/0\",\r\n          \"identity\": [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"]\r\n        },\r\n        {\r\n          \"ref\":      \"#/authors/1\",\r\n          \"identity\": [\"b3e0fac1-603f-4960-8646-90b053b6af19\"]\r\n        }\r\n      ],\r\n      \"publisher\": {\r\n        \"ref\":      \"#/publishers/0\",\r\n        \"identity\": [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nI explicitly made the `relation` instance an object, because that gives us the opportunity to declare a `qualifier` type in the `relation` which defines/references a type to qualify the relationship further, equivalent to link properties in a graph.\r\n\r\nExample:\r\n\r\nqualifier type:\r\n\r\n```\r\n\"AuthorRole\": {\r\n  \"type\": \"string\",\r\n  \"enum\": [\"Author\", \"Editor\", \"Illustrator\", \"Translator\"]\r\n}\r\n```\r\n\r\nextend the relation:\r\n\r\n```\r\n\"authors\": {\r\n  \"targettype\":  { \"$ref\": \"#/definitions/Library/Author\" },\r\n  \"cardinality\": \"multiple\",\r\n\r\n  /* NEW \u2013 the schema that qualifies the link                *\r\n   * Every relation-instance object MUST carry a `qualifier`  *\r\n   * that validates against this type.                       */\r\n  \"qualifiertype\": { \"$ref\": \"#/definitions/Library/AuthorRole\" }\r\n}\r\n```\r\n\r\nInstance with qualifiers:\r\n\r\n```\r\n{\r\n  \"$schema\": \"https://example.com/library.schema\",\r\n\r\n  \"authors\": [\r\n    { \"id\": \"3aad369c-1bfb-11e5-9a21-1697f925ec7b\", \"name\": \"Brian W. Kernighan\" },\r\n    { \"id\": \"b3e0fac1-603f-4960-8646-90b053b6af19\", \"name\": \"Dennis M. Ritchie\" }\r\n  ],\r\n\r\n  \"publishers\": [\r\n    { \"id\": \"9609d302-62fb-4d0a-9e71-86f744e3022c\", \"name\": \"Prentice Hall\" }\r\n  ],\r\n\r\n  \"books\": [\r\n    {\r\n      \"isbn\":  \"978-0131103627\",\r\n      \"title\": \"The C Programming Language\",\r\n\r\n      \"authors\": [\r\n        {\r\n          \"ref\":       \"#/authors/0\",\r\n          \"identity\":  [\"3aad369c-1bfb-11e5-9a21-1697f925ec7b\"],\r\n          \"qualifier\": \"Author\"          // \u2190 validated by AuthorRole enum\r\n        },\r\n        {\r\n          \"ref\":       \"#/authors/1\",\r\n          \"identity\":  [\"b3e0fac1-603f-4960-8646-90b053b6af19\"],\r\n          \"qualifier\": \"Author\"\r\n        }\r\n      ],\r\n\r\n      \"publisher\": {\r\n        \"ref\":       \"#/publishers/0\",\r\n        \"identity\":  [\"9609d302-62fb-4d0a-9e71-86f744e3022c\"]\r\n        /* no qualifier here because the relation         *\r\n         * lacks a `qualifiertype` in the declaration.    */\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n    ",
              "createdAt": "2025-07-02T11:15:16Z",
              "updatedAt": "2025-07-02T11:15:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuq6E",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:47:18Z",
          "updatedAt": "2025-07-03T05:47:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "You clarified it in another comment. \r\n\r\n```suggestion\r\nThe `targettype` is optional, but only applicable for object or tuple properties.\r\n```",
              "createdAt": "2025-07-03T05:47:18Z",
              "updatedAt": "2025-07-03T05:47:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOONqYn86xuu1L",
          "commit": {
            "abbreviatedOid": "8cbb31c"
          },
          "author": "Fannon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-03T05:52:37Z",
          "updatedAt": "2025-07-03T05:52:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I like where this is going, thanks for creating this example! \r\nMoving it to its own `relation` property as an array of object seems like a really good idea. \r\n\r\nWhere I'm unsure is if we can assume that the instances are structured like you propose. I see how it's nice to make each reference an object and for convenience also adding a \"ref\", but in many real data cases I've seen the references are just a string property or an array of strings. The concept also needs to work with this. So the \"reference\" in the schema has to point to the property that carries the ID of the reference, too?\r\n\r\nLet me get back on this to you when I have more time to think it through. ",
              "createdAt": "2025-07-03T05:52:37Z",
              "updatedAt": "2025-07-03T05:52:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOONqYn86aktrc",
      "title": "Lift character set restriction on map keys",
      "url": "https://github.com/json-structure/core/pull/10",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #9\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-06-15T07:30:48Z",
      "updatedAt": "2025-06-15T07:32:21Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "034f99d5bf701da2d43c7f3a8f5bd182149f4a96",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue9",
      "headRefOid": "bf4e6e8d219a8d636cbccaacee32e25df2a25fb1",
      "closedAt": "2025-06-15T07:32:12Z",
      "mergedAt": "2025-06-15T07:32:12Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOONqYn86dE9Wn",
      "title": "Clemensv/issue6",
      "url": "https://github.com/json-structure/core/pull/11",
      "state": "MERGED",
      "author": "clemensv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #6\n\nSigned-off-by: Clemens Vasters <clemens@vasters.com>",
      "createdAt": "2025-07-02T12:35:50Z",
      "updatedAt": "2025-07-02T12:36:11Z",
      "baseRepository": "json-structure/core",
      "baseRefName": "main",
      "baseRefOid": "45a84114fc5c260bb5cc54cab3e9a8e007c1ba81",
      "headRepository": "json-structure/core",
      "headRefName": "clemensv/issue6",
      "headRefOid": "cce9997c2154723262149595d31ab1ce561ae6cf",
      "closedAt": "2025-07-02T12:35:58Z",
      "mergedAt": "2025-07-02T12:35:58Z",
      "mergedBy": "clemensv",
      "mergeCommit": {
        "oid": "4aeb7e24ee63935d52e768631e4f6c892851c19f"
      },
      "comments": [],
      "reviews": []
    }
  ]
}